var documenterSearchIndex = {"docs":
[{"location":"lib/internals/","page":"Internals","title":"Internals","text":"info: Important Note:\nThis documentation pertains to SNaQ v1.1 and may differ from the specific implementation originally described in Solís-Lemus & Ané (2016). See documentation SNaQ v1.0  for the original implementation.","category":"page"},{"location":"lib/internals/#Internal-Documentation","page":"Internals","title":"Internal Documentation","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Documentation for SNaQ's internal functions. These functions are not exported and their access (API) should not be considered stable. But they can still be used, like this for example: SNaQ.foo() for a function named foo().","category":"page"},{"location":"lib/internals/#Functions-and-Types","page":"Internals","title":"Functions & Types","text":"","category":"section"},{"location":"lib/internals/#SNaQ.QuartetNetwork","page":"Internals","title":"SNaQ.QuartetNetwork","text":"QuartetNetwork(net::HybridNetwork)\n\nSubtype of Network abstract type. A QuartetNetwork object is an internal type used to calculate the expected CFs of quartets on a given network. Attributes of the QuartetNetwork objects need not be updated at a given time (see below).\n\nThe procedure to calculate expected CFs for a given network is as follows:\n\nA QuartetNetwork object is created for each Quartet using extractQuartet!(net,d) for net::HybridNetwork and d::DataCF\nThe vector d.quartet has all the Quartet objects, each with a QuartetNetwork object (q.qnet). Attibutes in QuartetNetwork are not updated at this point\nAttributes in QuartetNetwork are partially updated when calculating the expected CF (calculateExpCFAll!). To calculate the expected CF for this quartet, we need to update the attributes: which, typeHyb, t1, split, formula, expCF. To do this, we need to modify the QuartetNetwork object (i.e. merge edges,...). But we do not want to modify it directly because it is connected to the original net via a map of the edges and nodes, so we use a deep copy: qnet=deepcopy(q.qnet) and then calculateExpCFAll!(qnet). Attributes that are updated on the original QuartetNetwork object q.qnet are:\nq.qnet.hasEdge: array of booleans of length equal to net.edge that shows which identifiable edges and gammas of net (ht(net)) are in qnet (and still identifiable). Note that the first elements of the vector correspond to the gammas.\nq.qnet.index: length should match the number of trues in qnet.hasEdge. It has the indexes in qnet.edge from the edges in qnet.hasEdge. Note that the first elements of the vector correspond to the gammas.\nq.qnet.edge: list of edges in QuartetNetwork. Note that external edges in net are collapsed when they appear in QuartetNetwork, so only internal edges map directly to edges in net\nq.qnet.expCF: expected CF for this Quartet\n\nWhy not modify the original QuartetNetwork? We wanted to keep the original QuartetNetwork stored in DataCF with all the identifiable edges, to be able to determine if this object had been changed or not after a certain optimization.\n\nThe process is:\n\nDeep copy of full network to create q.qnet for Quartet q. This QuartetNetwork object has only 4 leaves now, but does not have merged edges (the identifiable ones) so that we can correspond to the edges in net. This QuartetNetwork does not have other attributes updated.\nFor the current set of branch lengths and gammas, we can update the attributes in q.qnet to compute the expected CF. The functions that do this will \"destroy\" the QuartetNetwork object by merging edges, removing nodes, etc... So, we do this process in qnet=deepcopy(q.qnet), and at the end, only update q.qnet.expCF.\nAfter we optimize branch lengths in the full network, we want to update the branch lengths in q.qnet. The edges need to be there (which is why we do not want to modify this QuartetNetwork object by merging edges), and we do not do a deep-copy of the full network again. We only change the values of branch lengths and gammas in q.qnet, and we can re-calculate the expCF by creating a deep copy qnet=deepcopy(q.qnet) and run the other functions (which merge edges, etc) to get the expCF.\n\nFuture work: there are definitely more efficient ways to do this (without the deep copies). In addition, currently edges that are no longer identifiable in QuartetNetwork do not appear in hasEdge nor index. Need to study this.\n\njulia> net0 = readnewick(\"(s17:13.76,(((s3:10.98,(s4:8.99,s5:8.99)I1:1.99)I2:0.47,(((s6:2.31,s7:2.31)I3:4.02,(s8:4.97,#H24:0.0::0.279)I4:1.36)I5:3.64,((s9:8.29,((s10:2.37,s11:2.37)I6:3.02,(s12:2.67,s13:2.67)I7:2.72)I8:2.89)I9:0.21,((s14:2.83,(s15:1.06,s16:1.06)I10:1.78)I11:2.14)#H24:3.52::0.72)I12:1.47)I13:1.48)I14:1.26,(((s18:5.46,s19:5.46)I15:0.59,(s20:4.72,(s21:2.40,s22:2.40)I16:2.32)I17:1.32)I18:2.68,(s23:8.56,(s1:4.64,s2:4.64)I19:3.92)I20:0.16)I21:3.98)I22:1.05);\");\n\njulia> net = readnewicklevel1(writenewick(net0)) ## need level1 attributes for functions below\nHybridNetwork, Semidirected Network\n46 edges\n46 nodes: 23 tips, 1 hybrid nodes, 22 internal tree nodes.\ntip labels: s17, s3, s4, s5, ...\n(s4:8.99,s5:8.99,(s3:10.0,((((s6:2.31,s7:2.31)I3:4.02,(s8:4.97,#H24:0.0::0.279)I4:1.36)I5:3.64,((s9:8.29,((s10:2.37,s11:2.37)I6:3.02,(s12:2.67,s13:2.67)I7:2.72)I8:2.89)I9:0.21,((s14:2.83,(s15:1.06,s16:1.06)I10:1.78)I11:2.14)#H24:3.52::0.721)I12:1.47)I13:1.48,((((s18:5.46,s19:5.46)I15:0.59,(s20:4.72,(s21:2.4,s22:2.4)I16:2.32)I17:1.32)I18:2.68,(s23:8.56,(s1:4.64,s2:4.64)I19:3.92)I20:0.16)I21:3.98,s17:10.0)I22:1.26)I14:0.47)I2:1.99)I1;\n\njulia> q1 = Quartet(1,[\"s1\", \"s16\", \"s18\", \"s23\"],[0.296,0.306,0.398])\nnumber: 1\ntaxon names: [\"s1\", \"s16\", \"s18\", \"s23\"]\nobserved CF: [0.296, 0.306, 0.398]\npseudo-deviance under last used network: 0.0 (meaningless before estimation)\nexpected CF under last used network: Float64[] (meaningless before estimation)\n\njulia> qnet = SNaQ.extractQuartet!(net,q1)\ntaxa: [\"s1\", \"s16\", \"s18\", \"s23\"]\nnumber of hybrid nodes: 1\n\njulia> sum([SNaQ.istIdentifiable(e) for e in net.edge]) ## 23 identifiable edges in net\n23\n\njulia> idedges = [ee.number for ee in net.edge[[SNaQ.istIdentifiable(e) for e in net.edge]]];\n\njulia> print(idedges)\n[5, 6, 9, 11, 12, 13, 17, 20, 21, 22, 26, 27, 28, 29, 30, 31, 34, 38, 39, 40, 44, 45, 46]\n\njulia> length(qnet.hasEdge) ## 24 = 1 gamma + 23 identifiable edges\n24\n\njulia> sum(qnet.hasEdge) ## 8 = 1 gamma + 7 identifiable edges in qnet\n8\n\njulia> print(idedges[qnet.hasEdge[2:end]]) ## 7 id. edges: [12, 13, 29, 30, 31, 45, 46]\n[12, 13, 29, 30, 31, 45, 46]\n\njulia> qnet.edge[qnet.index[1]].number ## 11 = minor hybrid edge\n11\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#PhyloNetworks.printedges-Tuple{IO, SNaQ.QuartetNetwork}","page":"Internals","title":"PhyloNetworks.printedges","text":"printedges([io::IO,] quartetnet)\n\nPrint information on the edges of a QuartetNetwork object quartetnet:\n\nedge number\nnumbers of nodes attached to it\nedge length\nwhether it's a hybrid edge\nwhether it's a major edge\nits γ inheritance value\nif it could contain the root (this field is not always updated, though)\nin which cycle it is contained (-1 if no cycle)\nif its length is identifiable from quartet concordance factors.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#PhyloNetworks.tablequartetCF-Tuple{Vector{Quartet}}","page":"Internals","title":"PhyloNetworks.tablequartetCF","text":"tablequartetCF(vector of Quartet objects)\ntablequartetCF(DataCF)\ntablequartetCF(gene trees)\ntablequartetCF(gene tree file)\n\nBuild a NamedTuple containing observed quartet concordance factors, with the fields named:\n\nt1, t2, t3, t4 for the four taxon names in each quartet\nCF12_34, CF13_24, CF14_23 for the 3 quartets of a given four-taxon set\nngenes if this information is available for some quartets\n\nSome downstream functions may require the observed quartet concordance factors to be in a DataFrame, this can be easily converted by wrapping the output NamedTuple in the DataFrame() function\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.afterOptBL!-Tuple{HybridNetwork, DataCF, Bool, Bool, Bool, Integer, Vector{Int64}}","page":"Internals","title":"SNaQ.afterOptBL!","text":"afterOptBL!\n\nCheck if there are h==0,1;t==0,hz==0,1 cases in a network after calling optBL!.\n\nOutput: (successchange,flagh,flagt,flaghz) where successchange is false if could not add new hybrid; true otherwise. Flags flag* is false if there is problem with gamma, t=0 or gammaz.\n\nArguments:\n\ncloseN: move origin/target iftrue; iffalseadd/deleteNtimes before giving up (we have only testedcloseN=true`)\norigin=true will move origin, false will move target. We added this to avoid going back and forth between the same networks\nmovesgamma: vector of integers. Counts the number of times each move is proposed to fix a gamma zero problem. Proposal types and order: (add, mvorigin, mvtarget, chdir, delete, nni).\n\nProcedure:\n\nFirst we split the ht vector in nh,nt,nhz (gammas, lengths, gammaz)\nIf we find a h==0,1, we loop through nh to find a hybrid edge with h==0 or 1 and want to try to fix this by doing:\ngammaZero!(currT,d,edge,closeN,origin,N,movesgamma) which returns true if there was a successful change, and we stop the loop\nIf we find a t==0, we loop through all nt to find such edge, and do NNI move on this edge; return true if change successful and we stop the loop\nIf we find a hz==0,1, we loop through nhz to find such hybrid edge and call gammaZero! again\nIf we did a successful change, we run optBL again, and recheck if there are no more problems.\nReturns successchange, flagh, flagt,flaghz (flag=true means no problems)\nIf it is the multiple alleles case, it will not try to fix h==0,1;hz==0,1 because it can reach a case that violates the multiple alleles condition. If we add a check here, things become horribly slow and inefficient, so we just delete a hybridization that has h==0,1;hz==0,1\n\n** Important**: afterOptBL is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call afterOptBLRepeat.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.afterOptBLAll!-Tuple{HybridNetwork, DataCF, Integer, Bool, Float64, Float64, Bool, Vector{Int64}, Float64, Float64, Float64}","page":"Internals","title":"SNaQ.afterOptBLAll!","text":"afterOptBLAll!(currT, args...)\n\nTry to fix any gamma zero problem (h==0,1; t==0; hz==0,1) by calling afterOptBLRepeat!. If problems cannot be fixed, it will call moveDownLevel to delete the hybridization from the network. Like afterOptBLAllMultipleAlleles, this function is called after optBL.\n\nOutput: new approved network currT (no gammas=0.0)\n\nProcedure:\n\nWhile startover=true and tries<N\n\nWhile badliks < N2 (number of bad pseudolikelihoods are less than N2)\nRun success = afterOptBLRepeat\nIf success = true (it changed something):\nIf worse pseudolik, then go back to original topology currT, set startover=true and badliks++\nIf better pseudolik, then check flags. If all good, then startover=false; otherwise startover = true\nIf success = false (nothing changed), then set badliks=N2+1 (to end the while on currT)\nIf all flags are ok, then startover = false\nIf bad h or hz, then call moveDownLevel (delete one hybridization), and set startover = true (maybe deleting that hybridization did not fix other gamma zero problems)\nIf bad t, then set startover = false\nIf left second while by back to original currT, and still bad h/hz, then move down one level, and startover=true; otherwise startover=false\n\nIf first while ends by tries>N, then it checks one last time the flags, if bad h/hz will move down one level, and exit\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.afterOptBLRepeat!-Tuple{HybridNetwork, DataCF, Integer, Bool, Bool, Bool, Vector{Int64}}","page":"Internals","title":"SNaQ.afterOptBLRepeat!","text":"afterOptBLRepeat!\n\nRepeat afterOptBL!, which only does one change. Repeating multiple times is to be sure that we fix all the gamma zero problems, after every time a successful change happened. This is done only if closeN=false, because we would delete/add hybridizations and need to stop after tried N times. If closeN=true (default), then afterOptBLRepeat! only does one afterOptBL!, because in this case, only the neighbor edges need to be tested, and this would have been done already in gammaZero!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.calculateObsCFAll!-Tuple{DataCF, Union{Vector{Int64}, Vector{<:AbstractString}}}","page":"Internals","title":"SNaQ.calculateObsCFAll!","text":"calculateObsCFAll!(DataCF, taxa::Union{Vector{<:AbstractString}, Vector{Int}})\n\nCalculate observed concordance factors: update the .quartet[i].obsCF values of the DataCF object based on its .tree vector.\n\ncalculateObsCFAll!(vector of quartets, vector of trees, taxa)\n\nCalculate observed concordance factors: update the .obsCF values of the quartets, based on the trees, and returns a new DataCF object with these updated quartets and trees.\n\ncalculateObsCFAll_noDataCF!(vector of quartets, vector of trees, taxa)\n\nupdate the .obsCF values of the quartets based on the trees, but returns nothing.\n\nWarning: all these functions need input trees (without any reticulations: h=0).\n\nSee also: PhyloNetworks.countquartetsintrees, which uses a faster algorithm, processing each input tree only once. calculateObsCFAll_noDataCF! processes each input tree # quartet times.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.checkMapDF-Tuple{DataFrames.DataFrame}","page":"Internals","title":"SNaQ.checkMapDF","text":"checkMapDF(mapping_allele2species::DataFrame)\n\nCheck that the data frame has one column named \"allele\" or \"individual\", and one column named \"species\". Output: indices of these column.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.deleteLeaf!-Tuple{PhyloNetworks.Network, AbstractString}","page":"Internals","title":"SNaQ.deleteLeaf!","text":"deleteLeaf!(net::HybridNetwork, leaf::AbstractString)\ndeleteLeaf!(net::Network, leaf::Node)\n\nDelete the leaf taxon from the network. The leaf argument is the name of the taxon to delete.\n\nWarnings:\n\nrequires a level-1 network with up-to-date attributes for snaq! (e.g. non-missing branch lengths, gammaz, etc.)\ndoes not care where the root is and does not update it to a sensible location if the root is affected by the leaf removal.\ndoes not merge edges, i.e. does not remove all nodes of degree 2. Within snaq!, this is used to extract quartets and to keep track of which edge lengths in the original network map to the quartet network.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.gammaZero!-Tuple{HybridNetwork, DataCF, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}","page":"Internals","title":"SNaQ.gammaZero!","text":"gammaZero!\n\nTry to fix a gamma zero problem (h==0,1; t==0; hz==0,1)\n\nFirst tries to do changeDirection: change the direction of hybrid edge\nIf changing the direction was successful, call optBL and check that the problem was fixed\nIf problem fixed and the pseudolik is not worse, return success=true\nIf changing the direction failed (step 1) or if the problem persists (step 2 failed) or if the pseudolik got worse (step 3 failed), then call moveHybrid!.\n\n** Important**: Any function (afterOptBL) calling gammaZero! is assuming that it only made a change, so if the returned value is true, then a change was made, and the other function needs to run optBL and check that all parameters are 'valid'. If the returned value is false, then no change was possible and we need to remove a hybridization if the problem is h==0,1; hz==0,1. If the problem is t==0, we ignore this problem.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.getNeighborsTarget-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"SNaQ.getNeighborsTarget","text":"getNeighborsTarget(hybrid_node, majoredge)\n\nVector of edges that are incident to either:\n\nthe node incident to majoredge other than hybrid_node, or\nthe tree child of hybrid_node.\n\nThis vector of edges is used as the list of suitable neighbors of \"othermin\" to move the target of a hybrid edge, in moveTargetUpdateRepeat!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.hybridatnode!-Tuple{HybridNetwork, Integer}","page":"Internals","title":"SNaQ.hybridatnode!","text":"hybridatnode!(net::HybridNetwork, nodeNumber::Integer)\n\nChange the direction and status of edges in network net, to move the hybrid node in a cycle to the node with number nodeNumber. This node must be in one (and only one) cycle, otherwise an error will be thrown. Check and update the nodes' field inCycle.\n\nOutput: net after hybrid modification.\n\nAssumption: net must be of level 1, that is, each blob has a single cycle with a single reticulation.\n\nexample\n\nnet = readnewick(\"(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;\");\nusing PhyloPlots\nplot(net, shownodenumber=true); # to locate nodes and their numbers. D of hybrid origin\nhybridatnode!(net, -4)\nplot(net, shownodenumber=true); # hybrid direction reversed: now 2B of hybrid origin\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.hybridatnode!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.Node}","page":"Internals","title":"SNaQ.hybridatnode!","text":"hybridatnode!(net::HybridNetwork, hybrid::Node, newNode::Node)\n\nMove the reticulation from hybrid to newNode, which must in the same cycle. net is assumed to be of level 1, but no checks are made and fields are supposed up-to-date.\n\nCalled by hybridatnode!(net, nodenumber), which is itself called by undirectedOtherNetworks.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.mapallelesCFtable!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, AbstractVector{Int64}, Bool, AbstractString}","page":"Internals","title":"SNaQ.mapallelesCFtable!","text":"mapallelesCFtable!(quartet CF DataFrame, mapping DataFrame, columns, write?, filename)\n\nModify (and return) the quartet concordance factor (CF) DataFrame: replace each allele name by the species name that the allele maps onto based on the mapping data frame. This mapping data frame should have columns named \"allele\" and \"species\" (see rename! to change column names if need be).\n\nIf write? is true, the modified data frame is written to a file named \"filename\".\n\nWarning: mapallelesCFtable takes the quartet data file as its second argument, while mapallelesCFtable! takes the quartet data (which it modifies) as its first argument.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.moveHybrid!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}","page":"Internals","title":"SNaQ.moveHybrid!","text":"moveHybrid!(net, edge, closeN, origin, N, movesgamma)\n\nDelete a hybrid, and then add a new hybrid. Attempt to fix a gamma zero problem (h==0,1; t==0; hz==0,1) after changing the direction of hybrid edge failed. This function is called in gammaZero!.\n\nArguments:\n\ncloseN=true will try move origin/target on all neighbors (first choose minor/major edge at random, then make list of all neighbor edges and tries to put the hybrid node in all the neighbors until successful move).   closeN=false will delete and add hybrid until successful move up to N times (this is never tested).\norigin: move the origin if true, moves the target if false. Option used to avoid coming back to propose the same network over and over.\nmovesgama: vector of integers. Counts the number of times each move is proposed to fix a gamma zero situation. Proposal types and order: (add, mvorigin, mvtarget, chdir, delete, nni)\n\nReturn true if change was successful (not testing optBL again), and false if we could not move anything.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.moveTargetUpdate!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Internals","title":"SNaQ.moveTargetUpdate!","text":"moveTargetUpdate!(net, hybrid_node, majoredge, newedge)\n\nModify a level-1 network net by moving majoredge, which should be a hybrid edge parent of hybrid_node. Within SNaQ, majoredge is chosen by chooseMinorMajor.\n\ncalls moveTarget!(net,hybrid_node, majoredge, treeedge_belowhybrid, newedge), which does the move but does not update any attributes\nupdates all level-1 attributes needed for SNaQ: gammaz, containroot\nun-does the move and updates if the move is invalid, through another call to moveTarget! but with the \"undo\" option.\n\nnewedge should be a tree edge (enforced by chooseEdgeOriginTarget!) adjacent to the parent node of majoredge or to the tree child of hybrid_node (enforced by getNeighborsTarget)\n\nOutput: tuple of 3 booleans (success, flag_triangle, flag_root).\n\nsuccess is false if the move failed (lead to an invalid network for SNaQ)\nflag_triangle is false if hasVeryBadTriangle(net)\nflag_root is false if the set of edges to place the root is empty\n\nIf success is false, then the flags are not meant to be used downstream.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.optBL!-Tuple{HybridNetwork, DataCF, Bool, Vararg{Float64, 4}}","page":"Internals","title":"SNaQ.optBL!","text":"optBL!(\n    net::HybridNetwork,\n    d::DataCF,\n    verbose::Bool,\n    ftolRel::Float64,\n    ftolAbs::Float64,\n    xtolRel::Float64,\n    xtolAbs::Float64\n)\n\nOptimize the edge parameters (lengths and inheritance probabilities γ) of a given level-1 network, using the BOBYQA algorithm from the NLopt package. The optimum found is used to modify net with new edge lengths, hybrid edge γs, and minimum loglik(net).\n\nWarning: net is assumed to have up-to-date and correct level-1 attributes. This is not checked for efficiency, because this function is called repeatedly inside optTopLevel! and snaq!.\n\nProcedure:\n\nht = parameters!(net) extracts the vector of parameters to estimate (h,t,gammaz), and sets as ht(net); identifies a bad diamond I, sets numht(net) (vector of hybrid node numbers for h, edge numbers for t, hybrid node numbers for gammaz), and index(net) to keep track of the vector of parameters to estimate\nextractQuartet!(net,d) does the following for all quartets in d.quartet:\nExtract quartet by deleting all leaves not in q -> create QuartetNetwork object saved in q.qnet\nThis network is ugly and does not have edges collapsed. This is done to keep a one-to-one correspondence between the edges in q.qnet and the edges in net (if we remove nodes with only two edges, we will lose this correspondence)\nCalculate expected CF with calculateExpCFAll for a copy of q.qnet. We do this copy because we want to keep q.qnet as it is (without collapsed edges into one). The function will then save the expCF in q.qnet.expCF\ncalculateExpCFAll!(qnet) will\nidentify the type of quartet as type 1 (equivalent to a tree) or type 2 (minor CF different). Here the code will first clean up any hybrid node by removing nodes with only two edges before identifying the qnet (because identification depends on neighbor nodes to hybrid node); later, set qnet.which (1 or 2), node.prev (neighbor node to hybrid node), updates k(node) (number of nodes in hybridization cycle, this can change after deleting the nodes with only two edges), typeHyb(node) (1,2,3,4,5 depending on the number of nodes in the hybridization cycle and the origin/target of the minor hybrid edge; this attribute is never used).\neliminate hybridization: this will remove type 1 hybridizations first. If qnet.which=1, then the qnet is similar to a tree quartet, so it will calculate the internal length of the tree quartet: qnet.t1.\nupdate split for qnet.which=1, to determine which taxa are together. For example, for the quartet 12|34, the split is [1,1,2,2] or [2,2,1,1], that is, taxon 1 and 2 are on the same side of the split. This will update qnet.split\nupdate formula for qnet.which=1 to know the order of minorCF and majorCF in the vector qnet.expCF. That is, if the quartet is 1342 (order in qnet.quartet.taxon), then the expected CF should match the observed CF in 13|42, 14|32, 12|34 and the qnet is 12|34 (given by qnet.split), qnet.formula will be [2,2,1] minor, minor, major\ncalculateExpCF!(qnet) for qnet.which=1, it will do 1-2/3exp(-qnet.t1) if qnet.formula[i]==1, and 1/3exp(qnet.t1) if qnet.formula[i]==2. For qnet.which=2, we need to make sure that there is only one hybrid node, and compute the major, minor1,minor2 expected CF in the order 12|34, 13|24, 14|23 of the taxa in qnet.quartet.taxon\n\nThen we create a NLopt object with algorithm BOBYQA and k parameters (length of ht). We define upper and lower bounds and define the objective function that should only depend on x=(h,t,gz) and g (gradient, which we do not have, but still need to put as argument).\n\nThe objective function obj(x,g) calls\n\ncalculateExpCFAll!(d,x,net) needs to be run after extractQuartet(net,d) that will update q.qnet for all quartet.  Assumes that qnet.indexht is updated already: we only need to do this at the beginning of optBL! because the topology is fixed at this point)\nFirst it will update the edge lengths according to x\nIf the q.qnet.changed=true (that is, any of qnet branches changed value), we need to call calculateExpCFAll!(qnet) on a copy of q.qnet (again because we want to leave q.qnet with the edge correspondence to net)\nupdate!(net,x) simply saves the new x in ht(net)\n\nFinally, after calling NLopt.optimize, loglik(net) and ht(net) are updated with the optimum score and parameter values that were found. After optBL, we want to call afterOptBLAll (or afterOptBLAllMultipleAlleles) to check if there are h==0,1; t==0; hz==0,1.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.optTopLevel!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, IO, Bool}","page":"Internals","title":"SNaQ.optTopLevel!","text":"optTopLevel!(currT, args...)\n\nDoes most of the heavy-lifting of snaq!, to search the space of networks with at most hmax hybrid nodes. It optimizes the pseudolikelihood starting from network currT, and returns the best network. Unlike snaq!, it assumes that the starting topology currT is of level-1, and has all the attributes correctly updated. currT is modified.\n\nInput parameters:\n\nStarting topology currT, input data DataCF d, maximum number of hybridizations hmax\nNumerical optimization parameters:\nliktolAbs: stop the search if the change in loglik is smaller (in absolute value)\nNfail: number of failure networks with lower loglik before aborting\nftolRel, ftolAbs, xtolRel, xtolAbs: to stop the optimization of  edge parameters on each fixed topology\nPrint parameters: verbose, logfile, writelog\nParameters to tune the search in space of networks: closeN=true only propose move origin/target to neighbor edges (coded, but not tested with closeN=false), Nmov0 vector with maximum number of trials allowed per type of move (add, mvorigin, mvtarget, chdir, delete, nni), by default computed inside with coupon’s collector formulas\n\nThe optimization procedure keeps track of\n\nmovescount: count of proposed moves,\nmovesgamma: count of proposed moves to fix a gamma zero situation (see below for definition of this situation),\nmovesfail: count of failed moves by violation of level-1 network (inCycle attribute) or worse pseudolikelihood than current,\nfailures: number of failed proposals that had a worse pseudolikelihood\n\nOptimization procedure:\n\nWhile the difference between current loglik and proposed loglik is greater than liktolAbs, or failures<Nfail, or stillmoves=true:\n\nNmov is a vector with the maximum number of trial per move type: (add,mvorigin,mvtarget,chdir,delete,nni). Nmov is updated based on newT. The type of move proposed will depend on newT (which is the same as currT at this point). For example, if currT is a tree, we cannot propose move origin/target.\nmove = whichMove selects randomly a type of move, depending on Nmov,movesfail,hmax,newT with weights 1/5 by default for all, and 0 for delete. These weights are adjusted depending on newT.numhybrids and hmax. If newT.numhybrids is far from hmax, we give higher probability to adding a new hybrid (we want to reach the hmax sooner, maybe not the best strategy, easy to change).  Later, we adjust the weights by movesfail (first, give weight of 0 if movesfail[i]>Nmov[i], that is, if we reached the maximum possible number of moves allowed for a certain type) and then increase the probability of the other moves.  So, unless one move has w=0, nothing changes. This could be improved by using the outlier quartets to guide the proposal of moves.\nwhichMove will choose a move randomly from the weights, it will return none if no more moves allowed, in which case, the optimization ends\nflag=proposedTop!(move, newT) will modify newT based on move. The function proposedTop will return flag=true if the move was successful (the move succeeded by inCycle, containroot, available edge to make the move (more details in proposedTop)). If flag=false, then newT is cleaned, except for the case of multiple alleles. The function proposedTop keeps count of movescount (successful move), movesfail (unsuccessful move),\nOptions:\nrandom=true: moves major/minor hybrid edge with prob h,1-h, respectively\nN=10: number of trials for NNI edge.\nif(flag) Optimize branch lengths with optBL\nIf loglik(newT) is better than loglik(currT) by liktolAbs, jump to newT (accepted=true) and fix gamma=0, t=0 problems (more info on afterOptBL)\nIf(accepted)   failures=0, movesfail=zeros, movescount for successful move +1\n\nend while\n\nAfter choosing the best network newT, we do one last more thorough optimization of branch lengths with optBL, we change non identifiable branch lengths to -1 (only in debug mode) and return newT\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.optTopRun1!-Tuple{HybridNetwork, Any, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, IO, Bool, Float64, Float64}","page":"Internals","title":"SNaQ.optTopRun1!","text":"optTopRun1!(net, liktolAbs, Nfail, d::DataCF, hmax, etc.)\n\nThe function will run 1 run by modifying the starting topology and calling optTopLevel. See optTopRuns! for a roadmap.\n\nprobST (default in snaq is 0.3) is the probability of starting one run at the same input tree. So, with probability 1-probST, we will change the topology by a NNI move on a tree edge without neighbor hybrid. If the starting topology is a network, then with probability 1-probST it will also modify one randomly chosen hybrid edge: with prob 0.5, the function will move origin, with prob 0.5 will do move target.\n\nIf there are multiple alleles (d.repSpecies not empty), then the function has to check that the starting topology does not violate the multiple alleles condition.\n\nAfter modifying the starting topology with NNI and/or move origin/target, optTopLevel is called.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.optTopRuns!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, AbstractString, AbstractString, Integer, Float64, Float64, Float64}","page":"Internals","title":"SNaQ.optTopRuns!","text":"Road map for various functions behind snaq!\n\nsnaq!\noptTopRuns!\noptTopRun1!\noptTopLevel!\noptBL!\n\nAll return their optimized network.\n\nsnaq! calls optTopRuns! once, after a deep copy of the starting network. If the data contain multiple alleles from a given species, snaq! first expands the leaf for that species into 2 separate leaves, and merges them back into a single leaf after calling optTopRuns!.\noptTopRuns! calls optTopRun1! several (nrun) times. assumes level-1 network with >0 branch lengths. assumes same tips in network as in data: i.e. 2 separate tips per species                                          that has multiple alleles. each call to optTopRun1! gets the same starting network.\noptTopRun1! calls optTopLevel! once, after deep copying + changing the starting network slightly.\noptTopLevel! calls optBL! various times and proposes new network with various moves.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.proposedTop!-Tuple{Integer, HybridNetwork, Bool, Integer, Integer, Vector{Int64}, Vector{Int64}, Bool, Float64, DataCF}","page":"Internals","title":"SNaQ.proposedTop!","text":"proposedTop!(move,newT,random,count,N,movescount,movesfail,multall)\n\nChange the current network newT by a given move, and check that the move was successful (correct attributes). If not successful, newT is changed back to its original state, except for the case of multiple alleles.\n\nNote that the update of attributes by each move is not done in all the network, but only in the local edges that were changed by the move. This is efficient (and makes a move easy to undo), but makes the code of each move function very clunky.\n\nArguments:\n\nmove chosen from whichMove as described in optTopLevel!\nnewT is the topology that will be modified inside with the move\nrandom=true: choose the minor hybrid edge with probability 1-h, and major edge with probability h. If false: always choose the minor hybrid edge\ncount: simply which likelihood step we are in, in the optimization at optTopLevel!\nN: number of attempts for NNI moves\nmovescount and movesfail: vector of counts of number of moves proposed. move types and order: (add,mvorigin,mvtarget,chdir,delete,nni).\nmultall=true if multiple alleles case: we need to check if the move did not violate the multiple alleles condition (sister alleles together and no gene flow into the alleles). This is inefficient because we are proposing moves that we can reject later, instead of being smart about the moves we propose: for example, move origin/target could rule out some neighbors that move gene flow into the alleles, the same for add hybridization; nni move can check if it is trying to separate the alleles)\n\nMoves:\n\naddHybridizationUpdate(newT,N):\n\nwill choose a partition first (to avoid choosing edges that will create a non level-1 network) will choose two edges from this partition randomly, will not allow two edges in a cherry (non-identifiable), or sister edges that are not identifiable (the blacklist was a way to keep track of \"bad edges\" were we should not waste time trying to put hybridizations, it has never been used nor tested). Also choose gamma from U(0,0.5). The \"Update\" in the function name means that it creates the new hybrid, and also updates all the attributes of newT\n\nnode = chooseHybrid(newT) choose a hybrid randomly for the next moves:\nmoveOriginUpdateRepeat!(newT,node,random)\n\nwill choose randomly the minor/major hybrid edge to move (if random=true); will get the list of all neighbor edges where to move the origin, will move the origin and update all the attributes and check if the move was successful (not conflicting attributes); if not, will undo the move, and try with a different neighbor until it runs out of neighbors. Return true if the move was successful.\n\nmoveTargetUpdateRepeat!(newT,node,random)\n\nsame as move origin but moving the target\n\nchangeDirectionUpdate!(newT,node,random)\n\nchooses minor/major hybrid edge at random (if `random=true), and changes the direction, and updates all the attributes. Checks if the move was successful (returns true), or undoes the change and returns false.\n\ndeleteHybridizationUpdate!(newT,node)\n\nremoves the hybrid node, updates the attributes, no need to check any attributes, always successful move\n\nNNIRepeat!(newT,N)\n\nchoose an edge for nni that does not have a neighbor hybrid. It will try to find such an edge N times, and if it fails, it will return false (unsuccessful move). N=10 by default. If N=1, it rarely finds such an edge if the network is small or complex. The function cannot choose an external edge. it will update locally the attributes.\n\n** Important: ** All the moves undo what they did if the move was not successful, so at the end you either have a newT with a new move and with all good attributes, or the same newT that started. This is important to avoid having to do deepcopy of the network before doing the move. Also, after each move, when we update the attributes, we do not update the attributes of the whole network, we only update the attributes of the edges that were affected by the move. This saves time, but makes the code quite clunky. Only the case of multiple alleles the moves does not undo what it did, because it finds out that it failed after the function is over, so just need to treat this case special.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.readInputData-Tuple{AbstractString, AbstractString, Symbol, Integer, Bool, AbstractString, Bool, Bool}","page":"Internals","title":"SNaQ.readInputData","text":"readInputData(trees, quartetfile, whichQuartets, numQuartets, writetable, tablename, writeQfile, writesummary)\nreadInputData(trees, whichQuartets, numQuartets, taxonlist,   writetable, tablename, writeQfile, writesummary)\n\nRead gene trees and calculate the observed quartet concordance factors (CF), that is, the proportion of genes (and the number of genes) that display each quartet for a given list of four-taxon sets.\n\nInput:\n\ntrees: name of a file containing a list of input gene trees, or vector of trees (HybridNetwork objects)\n\nOptional arguments (defaults):\n\nquartetfile: name of a file containing a list of quartets, or more precisely, a list of four-taxon sets\nwhichQuartets (:all): which quartets to sample. :all for all of them, :rand for a random sample.\nnumQuartets: number of quartets in the sample. default: total number of quartets if whichQuartets=:all and 10% of total if whichQuartets=:rand\ntaxonlist (all in the input gene trees): If taxonlist is used, whichQuartets will consist of all sets of 4 taxa in the taxonlist. \nwritetable (true): write the table of observed CF?\ntablename (\"tableCF.txt\"): if writetable is true, the table of observed CFs is write to file tablename\nwriteQfile (false): write intermediate file with sampled quartets?\nwritesummary (true): write a summary file? if so, the summary will go in file \"summaryTreesQuartets.txt\".\n\nUses calculateObsCFAll!, which implements a slow algorithm.\n\nSee also: PhyloNetworks.countquartetsintrees, which uses a much faster algorithm; readtrees2CF, which is an exported and user-friendly re-naming of readInputData, and readtableCF to read a table of quartet CFs directly.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.sameTaxa-Tuple{Quartet, HybridNetwork}","page":"Internals","title":"SNaQ.sameTaxa","text":"sameTaxa(Quartet, HybridNetwork)\n\nReturn true if all taxa in the quartet are represented in the network, false if one or more taxa in the quartet does not appear in the network.\n\nwarning: the name can cause confusion. A more appropriate name might be \"in\", or \"taxain\", or \"taxonsubset\", or etc.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.sampleCFfromCI","page":"Internals","title":"SNaQ.sampleCFfromCI","text":"sampleCFfromCI(data frame, seed=0)\nsampleCFfromCI!(data frame, seed=0)\n\nRead a data frame containing CFs and their credibility intervals, and sample new obsCF uniformly within the CIs. These CFs are then rescaled to sum up to 1 for each 4-taxon sets. Return a data frame with taxon labels in first 4 columns, sampled obs CFs in columns 5-7 and credibility intervals in columns 8-13.\n\nThe non-modifying function creates a new data frame (with re-ordered columns) and returns it. If seed=-1, the new df is a deep copy of the input df, with no call to the random number generator. Otherwise, seed is passed to the modifying function.\nThe modifying function overwrites the input data frame with the sampled CFs and returns it. If seed=0, the random generator is seeded from the clock. Otherwise the random generator is seeded using seed.\n\nWarning: the modifying version does not check the data frame: assumes correct columns.\n\noptional argument: delim=',' by default: how columns are delimited.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SNaQ.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}","page":"Internals","title":"SNaQ.setGammaBLfromGammaz!","text":"setGammaBLfromGammaz!(node, network)\n\nUpdate the γ values of the two sister hybrid edges in a bad diamond I, given the gammaz values of their parent nodes, and update the branch lengths t1 and t2 of their parent edges (those across from the hybrid nodes), in such a way that t1=t2 and that these branch lengths and γ values are consistent with the gammaz values in the network.\n\nSimilar to the first section of undoGammaz!, but does not update anything else than γ and t's. Unlike undoGammaz!, no error if non-hybrid node or not at bad diamond I.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.setLength!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Number}","page":"Internals","title":"SNaQ.setLength!","text":"setLength!(edge, newlength)`\n\nSet the length of edge, and set edge.y and edge.z accordingly. Warning: specific to SNaQ.jl. Consider PhyloNetworks.setlengths! from PhyloNetworks for a more generic tool.\n\nThe new length is censored to 10: if the new length is above 10, the edge's length will be set to 10. Lengths are interpreted in coalescent units, and 10 is close to infinity: near perfect gene tree concordance. 10 is used as an upper limit to coalescent units that can be reliably estimated.\nThe new length is allowed to be negative, but must be greater than -log(1.5), to ensure that the major quartet concordance factor (1 - 2/3 exp(-length)) is >= 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.setNonIdBL!-Tuple{HybridNetwork}","page":"Internals","title":"SNaQ.setNonIdBL!","text":"setNonIdBL!(net)\n\nSet non-identifiable edge branch lengths to -1.0 (i.e. missing) for a level-1 network net, except for edges in\n\na good triangle: the edge below the hybrid is constrained to 0.\na bad diamond II: the edge below the hybrid is constrained to 0\na bad diamond I: the edges across from the hybrid node have non identifiable lengths but are kept, because the two γ*(1-exp(-t)) values are identifiable.\n\nwill break if inCycle attributes are not initialized (at -1) or giving a correct node number.\n\nsee PhyloNetworks.Node for the meaning of boolean attributes isBadTriangle (which corresponds to a \"good\" triangle above), isBadDiamondI and isBadDiamondII.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.sorttaxa!-Tuple{DataCF}","page":"Internals","title":"SNaQ.sorttaxa!","text":"sorttaxa!(DataFrame, columns)\n\nReorder the 4 taxa and reorders the observed concordance factors accordingly, on each row of the data frame. If columns is ommitted, taxon names are assumed to be in columns 1-4 and CFs are assumed to be in columns 5-6 with quartets in this order: 12_34, 13_24, 14_23. Does not reorder credibility interval values, if present.\n\nsorttaxa!(DataCF)\nsorttaxa!(Quartet, permutation_tax, permutation_cf)\n\nReorder the 4 taxa in each element of the DataCF quartet. For a given Quartet, reorder the 4 taxa in its fields taxon and qnet.quartetTaxon (if non-empty) and reorder the 3 concordance values accordingly, in obsCF and qnet.expCF.\n\npermutation_tax and permutation_cf should be vectors of short integers (Int8) of length 4 and 3 respectively, whose memory allocation gets reused. Their length is not checked.\n\nqnet.names is unchanged: the order of taxon names here relates to the order of nodes in the network (???)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.taxadiff-Tuple{Vector{Quartet}, HybridNetwork}","page":"Internals","title":"SNaQ.taxadiff","text":"taxadiff(Vector{Quartet}, network; multiplealleles=true)\ntaxadiff(DataCF, network; multiplealleles=true)\n\nReturn 2 vectors:\n\ntaxa in at least 1 of the quartets but not in the network, and\ntaxa in the network but in none of the quartets.\n\nWhen multiplealleles is true, the taxon names that end with \"__2\" are ignored in the quartets: they are not expected to appear in the networks that users give as input, or get as output.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.traverseContainRoot!-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Bool}}","page":"Internals","title":"SNaQ.traverseContainRoot!","text":"updateContainRoot!(HybridNetwork, Node)\ntraverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})\n\nThe input node to updateContainRoot! must be a hybrid node (can come from PhyloNetworks.searchHybridNode). updateContainRoot! starts at the input node and calls traverseContainRoot!, which traverses the network recursively. By default, containroot attributes of edges are true. Changes containroot to false for all the visited edges: those below the input node, but not beyond any other hybrid node.\n\nupdateContainRoot! Returns a flag and an array of edges whose containroot has been changed from true to false. flag is false if the set of edges to place the root is empty\n\nIn traverseContainRoot!, rightDir turns false if hybridizations have incompatible directions (vector of length 1, to be modified).\n\nWarning:\n\ndoes not update containroot of minor hybrid edges.\nassumes correct ismajor attributes: to stop the recursion at minor hybrid edges.\nassumes correct hybrid attributes of both nodes & edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).\n\nrightDir: vector of length 1 boolean, to be mutable and modified by the function\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.undirectedOtherNetworks-Tuple{HybridNetwork}","page":"Internals","title":"SNaQ.undirectedOtherNetworks","text":"undirectedOtherNetworks(net::HybridNetwork)\n\nReturn a vector of HybridNetwork objects, obtained by switching the placement of each hybrid node to other nodes inside its cycle. This amounts to changing the direction of a gene flow event (recursively to move around the whole cycle of each reticulation).\n\nOptional argument: outgroup, as a String. If an outgroup is specified, then networks conflicting with the placement of the root are avoided.\n\nAssumptions: net is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. All level-1 fields of net are assumed up-to-date.\n\nExample\n\njulia> net = readnewick(\"(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;\");\njulia> vnet = undirectedOtherNetworks(net)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.undoGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}","page":"Internals","title":"SNaQ.undoGammaz!","text":"undoGammaz!(node, network)\n\nUndo updateGammaz! for the 2 cases: bad diamond I,II. node should be a hybrid node. Set length to edges that were not identifiable and change edges' gammaz attribute to -1.0. Recalculate branch lengths in terms of gammaz.   warning: needs to know incycle attributes\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.updateBL!-Tuple{HybridNetwork, DataCF}","page":"Internals","title":"SNaQ.updateBL!","text":"updateBL!(net::HybridNetwork, d::DataCF)\n\nUpdate internal branch lengths of net based on the average quartet concordance factor (CF) across all quartets that exactly correspond to a given branch: new branch length = -log(3/2(1-mean(CF observed in d))). net is assumed to be a tree, such that the above equation holds.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.updateContainRoot!","page":"Internals","title":"SNaQ.updateContainRoot!","text":"updateContainRoot!(HybridNetwork, Node)\ntraverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})\n\nThe input node to updateContainRoot! must be a hybrid node (can come from PhyloNetworks.searchHybridNode). updateContainRoot! starts at the input node and calls traverseContainRoot!, which traverses the network recursively. By default, containroot attributes of edges are true. Changes containroot to false for all the visited edges: those below the input node, but not beyond any other hybrid node.\n\nupdateContainRoot! Returns a flag and an array of edges whose containroot has been changed from true to false. flag is false if the set of edges to place the root is empty\n\nIn traverseContainRoot!, rightDir turns false if hybridizations have incompatible directions (vector of length 1, to be modified).\n\nWarning:\n\ndoes not update containroot of minor hybrid edges.\nassumes correct ismajor attributes: to stop the recursion at minor hybrid edges.\nassumes correct hybrid attributes of both nodes & edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).\n\nrightDir: vector of length 1 boolean, to be mutable and modified by the function\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SNaQ.updateSampledQuartetsAll!-Tuple{Vector{Quartet}, Bool}","page":"Internals","title":"SNaQ.updateSampledQuartetsAll!","text":"updateSampledQuartetsAll!(quartets::Vector{Quartet}, toset::Bool) Updates in-place all Quartet.sampled values where Quartet.uninformative=false      to the value provided in toset::Bool\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.updateSubsetQuartets!","page":"Internals","title":"SNaQ.updateSubsetQuartets!","text":"updateSubsetQuartets!(quartets::Vector{Quartet}, prop::Float64, update_uninformative=false)\nupdateSubsetQuartets!(d::DataCF, prop::Float64, update_uninformative=false)\n\nRandomly sample a proportion prop of quartets, and update in-place q.sampled to true for each quartet q. If update_uninformative is false, then we instead sample a proportion prop of informative quartets, that is, only sampling from quartets q such that q.uninformative is false).\n\nOutput: None, quartets (or d.quartet) is modified in-place\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SNaQ.updateUninformativeQuartets!-Tuple{Vector{Quartet}, Float64}","page":"Internals","title":"SNaQ.updateUninformativeQuartets!","text":"updateUninformativeQuartets!(quartets::Vector{Quartet}, tol::Float64) Checks for quartets classified as 'uninformative' given a tolerance to define CF equality      if all CFs in quartet.obsCF are equal within 'tol' tolerance,      quartet.sampled is set to 'false' Output: Updates quartet.sampled in-place for all quartets \n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.updateUninformativeQuartets-Tuple{Quartet, Float64}","page":"Internals","title":"SNaQ.updateUninformativeQuartets","text":"updateUninformativeQuartets(obsCF::Array{Float64}, tol::Float64) Returns value to place in quartet.sampled\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.writenewick_level1-Tuple{HybridNetwork}","page":"Internals","title":"SNaQ.writenewick_level1","text":"writenewick_level1(net::HybridNetwork)\n\nWrite the extended Newick parenthetical format of a level-1 network object with many optional arguments (see below). Makes a deep copy of net: does not modify net.\n\ndi=true: write in format for Dendroscope (default false)\nnamelabel=true: If namelabel is true, taxa are labelled by their names;\n\notherwise taxa are labelled by their numbers (unique identifiers).\n\noutgroup (string): name of outgroup to root the tree/network. if \"none\" is given, the root is placed wherever possible.\nprintID=true, only print branch lengths for identifiable egdes according to the snaq estimation procedure (default false) (true inside of snaq!.)\nround: rounds branch lengths and heritabilities γ (default: true)\ndigits: digits after the decimal place for rounding (defult: 3)\nstring: if true (default), returns a string, otherwise returns an IOBuffer object.\nmultall: (default false). set to true when there are multiple alleles per population.\n\nThe topology may be written using a root different than net.rooti, if net.rooti is incompatible with one of more hybrid node. Missing hybrid names are written as \"#Hi\" where \"i\" is the hybrid node number if possible.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SNaQ.fRel","page":"Internals","title":"SNaQ.fRel","text":"Default values for tolerance parameters used in the optimization of branch lengths and γ's (fAbs, fRel, xAbs, xRel) and acceptance of topologies (likAbs, numFails).\n\nBelow, PN refers to PhyloNetworks.jl, which contained snaq! up until PN v0.16. Starting with PN v0.17, snaq! is part of this package SNaQ.jl.\n\npkg version fRel fAbs xRel xAbs numFails likAbs multiplier\nSNaQ v0.1 1e-6 1e-6 1e-2 1e-3 75 1e-6 \nPN v0.5.1 1e-6 1e-6 1e-2 1e-3 75 1e-6 \nPN v0.3.0 1e-5 1e-6 1e-3 1e-4 100 0.01 \nPN v0.0.1 1e-5 1e-6 1e-3 1e-4 100  10000\nPN older 1e-12 1e-10 1e-10 1e-10   \n\nv0.5.1: based on Nan Ji's work. same xAbs and xRel as in phylonet (as of 2015). earlier: a multiplier was used; later: likAbs corresponds to multiplier*fAbs. \"older\": values from GLM.jl, Prof Bates\n\nDefault values used on a single topology to optimize branch lengths and gammas, at the very end of snaq!.\n\npkg version fRelBL fAbsBL xRelBL xAbsBL\nSNaQ v0.1 1e-12 1e-10 1e-10 1e-10\nPN v0.0.1 1e-12 1e-10 1e-10 1e-10\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"info: Important Note:\nThis documentation pertains to SNaQ v1.1 and may differ from the specific implementation originally described in Solís-Lemus & Ané (2016). See documentation SNaQ v1.0  for the original implementation.","category":"page"},{"location":"man/snaq_est/#Network-estimation","page":"Network estimation","title":"Network estimation","text":"","category":"section"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"SNaQ (v1.0) implements the statistical inference method in Solís-Lemus & Ané 2016. The procedure involves a numerical optimization of branch lengths and inheritance probabilities and a heuristic search in the space of phylogenetic networks.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"SNaQ (v1.1) implements the scalability improvements described in Kolbow et al 2025. These functionalities can be found in the Improving runtimes section.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"We suggest that you create a special directory for running these examples, where input files can be downloaded and where output files will be created (with estimated networks for instance). Enter this directory and run Julia from there.","category":"page"},{"location":"man/snaq_est/#Inputs-for-SNaQ","page":"Network estimation","title":"Inputs for SNaQ","text":"","category":"section"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"SNaQ uses has two main inputs for estimating phylogenetic networks: concordance factors (CFs) and a starting tree (or network).","category":"page"},{"location":"man/snaq_est/#Concordance-factors","page":"Network estimation","title":"Concordance factors","text":"","category":"section"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Concordance factors denote frequency of each quartet topology  present among the gene trees, which can be estimated using MrBayes or RAxML for example. ","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"PhyloUtilities has a step-by-step tutorial to go from multiple sequence alignments to a table of quartet gene frequencies (concordance factors: CFs), through BUCKy (to integrate out gene tree uncertainty) or through RAxML (see also the snaq tutorial). This pipeline uses sequence alignments in MrBayes to estimate gene trees, then BUCKy to produce the table of estimated CFs and their credibility intervals. Both steps in this pipeline are parallelized. ","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"info: input quartet CFs: BUCKy versus gene trees\nWhen quartet CFs are estimated using BUCKy on each subset of 4 taxa, then error in gene trees is accounted for: BUCKy aims to estimate true gene tree discordance, beyond discordance that is due to uncertainty in estimated gene trees. This is achieved in a Bayesian framework, using a full posterior sample of trees for each individual gene. So this method of obtaining quartet CFsis not what is sometimes referred to as a \"summary\" method\nis expected to be robust to gene tree estimation error.When quartet CFs are calculated based on a single tree per gene, then gene tree error is not accounted for. Estimation error in gene trees can cause gene tree discordance. Downstream analysis with SNaQ would need to invoke deep coalescence or introgression to account for this apparent discordance. So this methodmay be called a \"summary\" method\nmay be sensitive to gene tree estimation error.","category":"page"},{"location":"man/snaq_est/#CFs-from-gene-trees","page":"Network estimation","title":"CFs from gene trees","text":"","category":"section"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Suppose you have a file with a list of gene trees in parenthetical format called raxmltrees.tre. You can access the example file of input trees here (or here for easier download).","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Do not copy-paste into a \"smart\" text-editor. Instead, save the file directly into your working directory using \"save link as\" or \"download linked file as\". This file contains 30 gene trees, each in parenthetical format on 6 taxa like this (with rounded branch lengths):","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"(E:0.038,((A:0.014,B:0.010):0.010,(C:0.008,D:0.002):0.010):0.025,O:0.078);","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"If raxmltrees.tre is in your working directory, you can read in all gene trees and directly summarize them by a list of quartet CFs (proportion of input trees with a given quartet):","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"using PhyloNetworks,SNaQ\nraxmltrees = joinpath(dirname(pathof(SNaQ)), \"..\",\"examples\",\"raxmltrees.tre\");\nraxmlCF = readtrees2CF(raxmltrees) # read in the file and produce a \"DataCF\" object\n","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"In this table (tableCF.txt), each 4-taxon set is listed in one row. The 3 \"CF\" columns gives the proportion of genes that has each of the 3 possible trees on these 4 taxa.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"When there are many more taxa, the number of quartets might be very large and we might want to use a subset to speed things up. Here, if we wanted to use a random sample of 10 quartets instead of all quartets, we could do:","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"raxmlCF = readtrees2CF(raxmltrees, whichQ=\"rand\", numQ=10, CFfile=\"tableCF10.txt\")","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Be careful to use a numQ value smaller than the total number of possible 4-taxon subsets, which is n choose 4 on n taxa (e.g. 15 on 6 taxa). To get a predictable random sample, you may set the seed with using Random; Random.seed!(12321) (for instance) prior to sampling the quartets as above. Additionally, providing a file name for the optional argument CFile saves the quartet CFs to file for later use.","category":"page"},{"location":"man/snaq_est/#CFs-from-large-datasets","page":"Network estimation","title":"CFs from large datasets","text":"","category":"section"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"When we want to get all quartet CFs,  the readtrees2CF is much slower than the PhyloNetworks function PhyloNetworks.countquartetsintrees to read in trees and calculate the quartet CFs observed in the trees:","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"trees = readmultinewick(raxmltrees);\nq,t = countquartetsintrees(trees);\nnt = tablequartetCF(q,t); # named tuple\nusing DataFrames\ndf = DataFrame(nt, copycols=false); # convert to a data frame, without copying the column data\nshow(df, allcols=true) # data frames are displayed much more nicely than named tuples","category":"page"},{"location":"man/snaq_est/#Reading-CFs-directly-from-file","page":"Network estimation","title":"Reading CFs directly from file","text":"","category":"section"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"If we already have a table of quartet concordance factors (CFs) saved as a table in this format","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Taxon1 Taxon2 Taxon3 Taxon4 CF12_34 CF13_24 CF14_23\nD A E O 0.565 0.0903 0.3447\n...      ...","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"then we could read it in one step using the readtableCF function.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Concordance factors (CF), i.e. gene tree frequencies, for each 4-taxon subset can be obtained from BUCKy to account for gene tree uncertainty.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"An example file comes with the package, available here or here.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"buckyCFfile = joinpath(dirname(pathof(SNaQ)), \"..\",\"examples\",\"buckyCF.csv\");\nbuckyCF = readtableCF(buckyCFfile)","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"The same thing could be done in 2 steps: first to read the file and convert it to a DataFrame object from the DataFrames package and then to convert this DataFrame into a DataCF object.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"using CSV, DataFrames\ndat = CSV.read(buckyCFfile, DataFrame);\nfirst(dat, 6) # to see the first 6 rows\nbuckyCF = readtableCF(dat)\ntablequartetCF(buckyCF)","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"In the input file, columns need to be in the right order: with the first 4 columns giving the names of the taxa in each 4-taxon set. The CF values are assumed to be in columns named \"CF12_34\", etc., or else in columns 5,6,7. If available, a column named \"ngenes\" will be taken to have the the number of genes for each 4-taxon subset.","category":"page"},{"location":"man/snaq_est/#Starting-tree","page":"Network estimation","title":"Starting tree","text":"","category":"section"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"The other input for SNaQ is a starting tree (or network) to be used as a starting point in optimization.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"If we have a tree for the data set at hand, it can be used as a starting point for the optimization. From our gene trees, we estimated a species tree with ASTRAL. This tree comes with the package in file astral.tre here. This file has 102 trees: 100 bootstrap species trees, followed by their greedy consensus, followed by the best tree on the original data. It's this last tree that we are most interested in. We can read it with","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"astralfile = joinpath(dirname(pathof(SNaQ)), \"..\",\"examples\",\"astral.tre\");\nastraltree = readmultinewick(astralfile)[102] # 102th tree: last tree here","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Instead of a starting tree (astraltree in this case), we can start the optimization  in SNaQ with a network, but this network needs to be \"level-1\". Note that all trees and all networks with 1 hybridization are of level 1. To make sure that a network with 2 or more hybridizations is of level 1, we can read it in with readnewicklevel1 (which also unroots the tree, resolves polytomies, replaces missing branch lengths by 1 for starting values etc.):","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"T=readnewicklevel1(\"startNetwork.txt\")","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Here startNetwork.txt is a hypothetical file: replace this by the name of a file that contains your network of interest.","category":"page"},{"location":"man/snaq_est/#Estimating-a-network","page":"Network estimation","title":"Estimating a network","text":"","category":"section"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"After we have Inputs for SNaQ, we can estimate the network using the input data raxmlCF and starting from tree (or network) astraltree. We first set hmax=0 to impose the constraint of at most 0 hybrid node, that is, we estimate a tree.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"net0 = snaq!(astraltree,raxmlCF, hmax=0, filename=\"net0\", seed=1234)","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Part of the screen output shows this:","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"MaxNet is (C,D,((B,A):1.395762055180493,(O,E):0.48453400554506426):10.0);\nwith -loglik 53.53150526187732","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"This parenthetical (extended Newick) description is not very human-friendly, so we use PhyloPlots to plot the tree (more about plotting networks can be found in the PhyloNetworks guide Network Visualization  and in PhyloPlots documentation).","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"using PhyloPlots\nusing RCall # hide\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\" # hide\nR\"svg(name('snaqplot_net0_1.svg'), width=4, height=3)\" # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(net0);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"(Image: net0_1)","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"We can use this tree as a starting point to search for the best network allowing for at most hmax=1 hybridizations (which is the default if we do not specify a hmax value).","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"net1 = snaq!(net0, raxmlCF, hmax=1, filename=\"net1\", seed=2345)","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"part of screen output:","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"best network and networks with different hybrid/gene flow directions printed to .networks file\nMaxNet is (C,D,((O,(E,#H7:::0.19558838614943078):0.31352437658618976):0.6640664399202987,(B,(A)#H7:::0.8044116138505693):10.0):10.0);\nwith -loglik 28.31506721890958","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"We can visualize the estimated network and its inheritance values γ, which measure the proportion of genes inherited via each parent at a reticulation event (e.g. proportion of genes inherited via gene flow).","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"R\"svg(name('snaqplot_net1_1.svg'), width=4, height=3)\"; # hide\nR\"par\"(mar=[0,0,0,0]); # hide\nplot(net1, showgamma=true);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"(Image: net1_1)","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"This network has A as a hybrid, 80.4% sister to B, and 19.6% sister to E (which is otherwise sister to O). C & D are sister to each other.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Note that SNaQ infers an unrooted semi-directed network;  the lack of rooting is depicted visually with a trifurcationon on the leftmost side of the plot. The direction of hybrid edges can be inferred, but the direction of tree edges cannot be inferred. To obtain a representative visualization, it is best to root the network first, using one or more outgroup. PhyloNetworks has a guide on Re-rooting trees and networks for this. If your outgroup conflicts with the direction of reticulations in the estimated network, see the section Candidate networks compatible with a known outgroup.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"We can also check the output files created by snaq!:","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"less(\"net1.out\") # main output file with the estimated network from each run\nless(\"net1.networks\") # extra info","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"when viewing these result files with less within Julia, use arrows to scroll down and type q to quit viewing the files.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"The .networks file contains a list of networks that are slight modifications of the best (estimated) network net1. The modifications change the direction of one reticulation at a time, by moving the placement of one hybrid node to another node inside the same cycle. For each modified network, the pseudolikelihood score was calculated (the loglik or -Ploglik values give a pseudo-deviance actually).\nThe .out file contains the best network among all runs, and the best network per run, includes also the pseudolikelihood score and the computation time.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Additionally there is a folder that ends in _runs (in this case, net1_runs) that contains information about each independent run performed. There will be two files for each run:","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"The .log file contains a description of each run, convergence criterion, and seed information.\nThe .err file has seed information on runs that failed, empty when nothing failed.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"The function name snaq! ends with ! because it modifies the argument raxmlCF by including the expected CF. Type ? then snaq! to get help on that function.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"The main output file, here net1.out (or snaq.out by default) has the estimated network in parenthetical format, but we can also print it directly to the screen:","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"net1\nwritenewick(net1)  # writes to screen, full precision for branch lengths and γ\nwritenewick(net1, round=true, digits=2)\nwritenewick(net1, di=true) # γ omitted: for dendroscope\nwritenewick(net1, \"bestnet_h1.tre\") # writes to file: creates or overwrites file\nrm(\"bestnet_h1.tre\") # hide","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"From a set of candidate networks, one might simply need to score of each network to pick the best. Here, the score is the negative log pseudo-deviance, and the lower the better. See the section to get the score of Candidate networks.","category":"page"},{"location":"man/snaq_est/#Choosing-the-number-of-hybridizations-(hmax)","page":"Network estimation","title":"Choosing the number of hybridizations (hmax)","text":"","category":"section"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"We change the hmax argument to change the search space to let the network have up to 2 or 3 hybrid nodes:","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"net2 = snaq!(net1,raxmlCF, hmax=2, filename=\"net2\", seed=3456)\nnet3 = snaq!(net0,raxmlCF, hmax=3, filename=\"net3\", seed=4567)","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"and plot them (the optimized networks are identical and they both have a single reticulation):","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"R\"svg(name('snaqplot_net23.svg'), width=7, height=3)\" # hide\nusing RCall                  # to be able to tweak our plot within R\nR\"layout(matrix(1:2, 1, 2))\" # to get 2 plots into a single figure: 1 row, 2 columns\nR\"par\"(mar=[0,0,1,0])        # for smaller margins\nplot(net2, showgamma=true);\nR\"mtext\"(\"hmax=2\")           # add text annotation: title here\nplot(net3, showgamma=true);\nR\"mtext\"(\"hmax=3\")\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"(Image: net23)","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"with this screen output for net2 (only 1 hybrid node found):","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"MaxNet is (C,D,((B,(A)#H7:::0.804411606649347):10.0,(O,(#H7:::0.19558839335065303,E):0.3135243143217013):0.664066456871298):10.0);\nwith -loglik 28.31506721890957","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"and this output for net3 (again, only 1 hybrid found):","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"MaxNet is (D,C,((O,(E,#H7:::0.19558839257941849):0.3135243301652981):0.6640664138384673,(B,(A)#H7:::0.8044116074205815):10.0):10.0);\nwith -loglik 28.315067218909626","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Each network has an fscore attribute, which contains its log pseudo-deviance: a multiple of the negative log-likelihood up to a constant (the constant is such that the score is 0 if the network fits the data perfectly). The lower the better. We can plot these scores across hybrid values:","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"scores = [loglik(net0), loglik(net1), loglik(net2), loglik(net3)]\nhmax = collect(0:3)\nR\"svg(name('snaqplot_scores_heuristic.svg'), width=4, height=3)\" # hide\nR\"par\"(mar=[2.5,2.5,.5,.5], mgp=[1.4,.4,0], tck=-0.02, las=1, lab=[3,5,7]);  # hide\nR\"plot\"(hmax, scores, type=\"b\", ylab=\"network score\", xlab=\"hmax\", col=\"blue\");\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"(Image: scores_heuristic)","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Here the slope heuristic suggests a single hybrid node: the score does not get much better beyond h=1.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"We made the plot via R above. A more Julian way would use a Julia plotting package such as Plots, Makie or packages with similar principles to ggplot2 in R: AlgebraOfGraphics (based on Makie) or Gadfly. Also see this a cool (but now somewhat old) blog about using ggplot within julia.","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"Note that since SNaQ assumes level-1 networks (i.e., no intersecting cycles), it might not be possible to add more hybridizations to networks with few taxa: ","category":"page"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"(Image: level1)","category":"page"},{"location":"man/snaq_est/#Suggestions-and-best-practices","page":"Network estimation","title":"Suggestions and best practices","text":"","category":"section"},{"location":"man/snaq_est/","page":"Network estimation","title":"Network estimation","text":"For big datasets, do only one run (i.e., setting runs=1) first to get an idea of computing time:\nnet1 = snaq!(net0,raxmlCF, hmax=3, filename=\"net3\", runs=1)\nIncrease the number of hybridizations sequentially: hmax=0,1,2,..., and use the best network at h-1 as starting point to estimate the best network at h.\nWhenever possible, do many independent runs (default runs=10) to avoid getting stuck on local maxima. We do not need to do all runs sequentially. We can parallize by doing different runs on different cores (or computers). If we are on a machine or on a cluster that has many different cores, we can ask Julia to use these multiple cores, and snaq! will send different runs to different cores, like we did earlier.\nFor long jobs, run as a script in the terminal: julia runSNaQ.jl, arguments to the script are passed to Julia as a vector called ARGS. See the example script runSNaQ.jl in the examples folder of SNaQ, or the file located here. More on this topic in here: Improving runtimes","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"info: Important Note:\nThis documentation pertains to SNaQ v1.1 and may differ from the specific implementation originally described in Solís-Lemus & Ané (2016). See documentation SNaQ v1.0  for the original implementation.","category":"page"},{"location":"man/expectedCFs/#Quartet-test-for-goodness-of-fit","page":"Extract expected CFs","title":"Quartet test for goodness of fit","text":"","category":"section"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"One can formally assess whether an estimated network fits the concordance factor data with the QuartetNetworkGoodnessFit package in Julia. This package simulates concordance factors from the estimated network under the network multispecies coalescent, computes how often outlier quartet topologies are observed, and compares this to the observed concordance factors to perform a test for goodness-of-fit. See the QuartetNetworkGoodnessFit documentation for an example of this test.","category":"page"},{"location":"man/expectedCFs/#Visualizing-observed-and-expected-CFs","page":"Extract expected CFs","title":"Visualizing observed and expected CFs","text":"","category":"section"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"A good way to visualize the \"goodness-of-fit\" of a given estimated network to the data is to plot the observed CF versus the expected CF. If the network is a good fit, then the dots in the plot will be close to the diagonal (x=y line). The following function will create a dataframe with the observed and expected CFs, which are all saved in the DataCF object after running snaq:","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"topologymaxQpseudolik!(truenet, raxmlCF);\ndf_wide = fittedquartetCF(raxmlCF) # same as fittedquartetCF(raxmlCF, :wide)\ndf_long = fittedquartetCF(raxmlCF, :long)","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"It is important to have run snaq!, topologyQpseudolik! or topologymaxQpseudolik! before making these tables, or the result would be meaningless. These functions update the fitted concordance factors (those expected under the network) inside the DataCF object raxmlCF.","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"Here is one way to plot them, via R again, and using the R package ggplot2.","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"using RCall\nobsCF = df_long[!,:obsCF]; expCF = df_long[!,:expCF]; # hide\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\"; # hide\nR\"svg(name('expCFs_obsvsfitted.svg'), width=5, height=4)\"; # hide\nR\"par\"(mar=[2.5,2.6,.5,.5], mgp=[1.5,.4,0], tck=-0.01, las=1, pty=\"s\"); # hide\nR\"plot(0:1, 0:1, type='l', bty='L', lwd=0.3, col='#008080', xlab='quartet CF observed in gene trees', ylab='quartet CF expected from network')\"; # hide\nR\"set.seed\"(1234); # hide\nR\"points(jitter($obsCF,amount=0.005),jitter($expCF,amount=0.005),col='#008080',bg='#00808090',pch=21)\"; # hide\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"To install ggplot2 if not installed already, do: R\"install.packages('ggplot2', dep=TRUE)\"","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"@rlibrary ggplot2\nggplot(df_long, aes(x=:obsCF,y=:expCF)) + theme_classic() +\n    geom_segment(x=0,y=0,xend=1,yend=1, color=\"#008080\", size=0.3) + # diagonal line\n    geom_point(alpha=0.5, color=\"#008080\", position=position_jitter(width=0.005, height=0.005)) +\n    ylab(\"quartet CF expected from network\") + xlab(\"quartet CF observed in gene trees\") + coord_equal(ratio=1);\n# if needed, save with:\nggsave(\"expCFs_obsvsfitted.svg\", scale=1, width=6, height=5);","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"(Image: obsvsfitted)","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"Many points are overlapping, so they were \"jittered\" a little to see them all better. There are always many points overlapping on the bottom-left corner: concordance factors of 0.0 for quartet resolutions not observed, and not expected.   To export the table of quartet CFs and explore the fit of the network with other tools:","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"using CSV\nCSV.write(\"fittedCF.csv\", df_long)","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"We could highlight quartets that include taxon A, say, if we suspect that it is an unrecognized hybrid. Many points are overlapping, like before, so they are again \"jittered\" a bit.","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"using DataFrames\ndf_long[!,:has_A] .= \"no\"; # add a column to our data, to indicate which 4-taxon sets have A or not\nfor r in eachrow(df_long)\n    if \"A\" ∈ [r[:tx1], r[:tx2], r[:tx3], r[:tx4]]\n       r[:has_A]=\"yes\"\n    end\nend\nhas_A = df_long.has_A # hide\nnq = length(has_A); # hide\nR\"colA=rep('#008080',$nq); bgA=rep('#00808090',$nq);\"; # hide\nR\"colA[$has_A=='yes']='#F8766D'; bgA[$has_A=='yes']='#F8766D90'\"; # hide\nR\"svg(name('expCFs_obsvsfitted_A.svg'), width=5, height=4)\"; # hide\nR\"par\"(mar=[2.5,2.6,.5,.5], mgp=[1.5,.4,0], tck=-0.01, las=1, pty=\"s\"); # hide\nR\"plot(0:1, 0:1, type='l', bty='L', lwd=0.3, col='black', xlab='quartet CF observed in gene trees', ylab='quartet CF expected from network')\"; # hide\nR\"set.seed\"(2345); # hide\nR\"points(jitter($obsCF,amount=0.005),jitter($expCF,amount=0.005),col=colA,bg=bgA,pch=21)\"; # hide\nR\"legend(x=0.7,y=0.3,pch=21,col=c('#008080','#F8766D'),legend=c('no','yes'),title='has A?', bty='n',bg=c('#00808090','#F8766D90'))\"; # hide\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"first(df_long, 7) # first 7 rows","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"ggplot(df_long, aes(x=:obsCF, y=:expCF, color=:has_A)) + theme_classic() +\n    geom_segment(x=0,y=0,xend=1,yend=1, color=\"black\", size=0.3) + # diagonal line\n    geom_point(alpha=0.5, position=position_jitter(width=0.005, height=0.005)) +\n    ylab(\"quartet CF expected from network\") + xlab(\"quartet CF observed in gene trees\") + coord_equal(ratio=1);\n# can be saved:\nggsave(\"expCFs_obsvsfitted_A.svg\", width=6, height=5);","category":"page"},{"location":"man/expectedCFs/","page":"Extract expected CFs","title":"Extract expected CFs","text":"(Image: obsvsfitted A present or not)","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"info: Important Note:\nThis documentation pertains to SNaQ v1.1 and may differ from the specific implementation originally described in Solís-Lemus & Ané (2016). See documentation SNaQ v1.0  for the original implementation.","category":"page"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Documentation for SNaQ's public (exported) interface.","category":"page"},{"location":"lib/public/#Functions-and-Types","page":"Public","title":"Functions & Types","text":"","category":"section"},{"location":"lib/public/#SNaQ.bootsnaq-Tuple{HybridNetwork, Union{DataFrames.DataFrame, Vector{Vector{HybridNetwork}}}}","page":"Public","title":"SNaQ.bootsnaq","text":"bootsnaq(T::HybridNetwork, df::DataFrame)\nbootsnaq(T::HybridNetwork, vector of tree lists)\n\nBootstrap analysis for SNaQ. Bootstrap data can be quartet concordance factors (CF), drawn from sampling uniformly in their credibility intervals, as given in the data frame df. Alternatively, bootstrap data can be gene trees sampled from a vector of tree lists: one list of bootstrap trees per locus (see readmultinewick_files in PhyloNetworks to generate this, from a file containing a list of bootstrap files: one per locus).\n\nFrom each bootstrap replicate, a network is estimated with snaq!, with a search starting from topology T. Optional arguments include the following, with default values in parentheses:\n\nhmax (1): max number of reticulations in the estimated networks\nnrep (10): number of bootstrap replicates.\nruns (10): number of independent optimization runs for each replicate\nfilename (\"bootsnaq\"): root name for output files. No output files if \"\".\nseed (0 to get a random seed from the clock): seed for random number generator\notherNet (empty): another starting topology so that each replicate will start prcnet% runs on otherNet and (1-prcnet)% runs on T\nprcnet (0): percentage of runs starting on otherNet; error if different than 0.0, and otherNet not specified.\nftolRel, ftolAbs, xtolRel, xtolAbs, liktolAbs, Nfail, probST, verbose, outgroup: see snaq!, same defaults.\n\nIf T is a tree, its branch lengths are first optimized roughly with updateBL! (by using the average CF of all quartets defining each branch and calculating the coalescent units corresponding to this quartet CF). If T has one or more reticulations, its branch lengths are taken as is to start the search. The branch lengths of otherNet are always taken as is to start the search.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SNaQ.fittedquartetCF","page":"Public","title":"SNaQ.fittedquartetCF","text":"fittedquartetCF(d::DataCF, format::Symbol)\n\nData frame with the observed and expected quartet concordance factors after estimation of a network with snaq!, or fitting of quartet CF data on a fixed network. The format can be :wide (default) or :long.\n\nif wide, the output has one row per 4-taxon set, and each row has 10 columns: 4 columns for the taxon names, 3 columns for the observed CFs and 3 columns for the expected CF.\nif long, the output has one row per quartet, i.e. 3 rows per 4-taxon sets, and 7 columns: 4 columns for the taxon names, one column to give the quartet resolution, one column for the observed CF and the last column for the expected CF.\n\nsee also: topologyQpseudolik! and topologymaxQpseudolik! to update the fitted quartet CF expected under a specific network, inside the DataCF object d.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SNaQ.mapallelesCFtable-Tuple{AbstractString, AbstractString}","page":"Public","title":"SNaQ.mapallelesCFtable","text":"mapallelesCFtable(mapping file, CF file; filename, columns, delim)\n\nCreate a new DataFrame containing the same concordance factors as in the input CF file, but with modified taxon names. Each allele name in the input CF table is replaced by the species name that the allele maps onto, based on the mapping file. The mapping file should have column names: allele and species.\n\nOptional arguments:\n\nfilename to write/save resulting CF table. If not specified, then the output data frame is not saved to a file.\ncolumns column numbers for the taxon names. 1-4 by default.\nany keyword arguments that CSV.File would accept. For example, delim=',' by default: columns are delimited by commas. Unless specified otherwise by the user, pool=false (to read taxon names as Strings, not levels of a categorical factor, for combining the 4 columns with taxon names more easily). The same CSV arguments are used to read both input file (mapping file and quartet file)\n\nSee also mapallelesCFtable! to input DataFrames instead of file names.\n\nIf a filename is specified, such as \"quartetCF_speciesNames.csv\" in the example below, this file is best read later with the option pool=false. example:\n\nmapallelesCFtable(\"allele-species-map.csv\", \"allele-quartet-CF.csv\";\n                  filename = \"quartetCF_speciesNames.csv\")\ndf_sp = CSV.read(\"quartetCF_speciesNames.csv\", DataFrame); # DataFrame object\ndataCF_specieslevel = readtableCF!(df_sp, mergerows=true); # DataCF object\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SNaQ.readmultinewicklevel1-Tuple{AbstractString}","page":"Public","title":"SNaQ.readmultinewicklevel1","text":"readmultinewicklevel1(file)\n\nRead a text file with a list of trees/networks in extended newick format (one tree per line) and transform them like readnewicklevel1. Namely, in each tree/network\n\nthe root is suppressed (becomes of degree 3 if it was of degree 2)\nany polytomy is resolved arbitrarily\nany missing branch length is set to 1\nany branch length above 10 is set to 10 (this assumes branch lengths in coalescent units)\nany missing γ's are set to (0.1, 0.9)\n\nand more (see readnewicklevel1).\n\nSee PhyloNetworks.readmultinewick to read multiple trees or networks with no modification.\n\nOutput: array of HybridNetwork objects.\n\nEach line starting with \"(\" will be considered as describing one topology. The file can have extra lines that are ignored.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SNaQ.readnewicklevel1-Tuple{AbstractString}","page":"Public","title":"SNaQ.readnewicklevel1","text":"readnewicklevel1(filename)\nreadnewicklevel1(parenthetical format)\n\nSimilarly to PhyloNetworks.readnewick: read a tree or network in parenthetical format, but this function enforces the necessary conditions for any starting topology in SNaQ: non-intersecting cycles, no polytomies, unrooted. It sets any missing branch length to 1.0, and reduces any branch length above 10 to 10 (as it assumes branch lengths are in coalescent units).\n\nIf the network has a bad diamond II (in which edge lengths are γ's are not identifiable) and if the edge below this diamond has a length t different from 0, then this length is set back to 0 and the major parent hybrid edge is lengthened by t.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SNaQ.readsnaqnetwork-Tuple{AbstractString}","page":"Public","title":"SNaQ.readsnaqnetwork","text":"readsnaqnetwork(output file)\n\nRead the estimated network from a .out file generated by snaq!. The network score is read also, and stored in the network's field .fscore.\n\nWarning: the score is not the log likelihood and is instead proportional to the network's pseudo-deviance: the lower, the better. Do NOT use this score to calculate an AIC or BIC (etc.) value.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SNaQ.readtableCF!-Tuple{DataCF, DataFrames.DataFrame, Vector{Int64}}","page":"Public","title":"SNaQ.readtableCF!","text":"readtableCF!(data frame, columns; mergerows=false)\n\nRead in quartet CFs from data frame, assuming information is in columns numbered columns, of length 7 or 8: 4 taxon labels then 3 CFs then ngenes possibly.\n\nIf some species appears more than once in the same 4-taxon set (e.g. t1,t1,t2,t3), then the data frame is modified to remove rows (4-taxon sets) that are uninformative about between-species relationships. This situation may occur if multiple individuals are sampled from the same species. A 4-taxon set is uninformative (and its row is removed) if one taxon is repeated 3 or 4 times (like t1,t1,t1,t1 or t1,t2,t2,t2). The list of species appearing twice in some 4-taxon sets is stored in the output DataCF object. For these species, the length of their external edge is identifiable (in coalescent units). If multiple rows correspond to the same 4-taxon set, these rows are merged and their CF values (and number of genes) are averaged. If none of the species is repeated within any 4-taxon set, then this averaging is attempted only if mergerows is true.\n\nreadtableCF!(DataCF, data frame, columns)\n\nModify the .quartet.obsCF values in the DataCF object with those read from the data frame in columns numbered columns. columns should have 3 columns numbers for the 3 CFs in this order: 12_34, 13_24 and 14_23.\n\nAssumptions:\n\nsame 4-taxon sets in DataCF and in the data frame, and in the same order, but this assumption is not checked (for speed, e.g. during bootstrapping).\none single row per 4-taxon set (multiple individuals representatives of the same 4-taxon set should have been already merged); basically: the DataCF should have been created from the data frame by readtableCF!(df, colums)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SNaQ.readtableCF-Tuple{AbstractString}","page":"Public","title":"SNaQ.readtableCF","text":"readtableCF(file)\nreadtableCF(data frame)\nreadtableCF!(data frame)\n\nRead a file or DataFrame object containing a table of concordance factors (CF), with one row per 4-taxon set. The first 4 columns are assumed to give the labels of the 4 taxa in each set (tx1, tx2, tx3, tx4). Columns containing the CFs are assumed to be named CF12_34, CF13_24 and CF14_23; or CF12.34, CF13.24 and CF14.23; or else are assumed to be columns 5,6,7. If present, a column named 'ngenes' will be used to get the number of loci used to estimate the CFs for each 4-taxon set.\n\nOutput: DataCF object\n\nOptional arguments:\n\nsummaryfile: if specified, a summary file will be created with that name.\ndelim (for the first form only): to specify how columns are delimited, with single quotes: delim=';'. Default is a csv file, i.e. delim=','.\nmergerows: false by default. When true, will attempt to merge multiple rows corresponding to the same four-taxon set (by averaging their quartet CFs) even if none of the species is repeated within any row (that is, in any set of 4 taxa)\n\nThe last version modifies the input data frame, if species are represented by multiple alleles for instance (see readtableCF!(data frame, columns)).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SNaQ.readtrees2CF-Tuple{AbstractString}","page":"Public","title":"SNaQ.readtrees2CF","text":"readtrees2CF(treefile)\nreadtrees2CF(vector of trees)\n\nRead trees in parenthetical format from a file, or take a vector of trees already read, and calculate the proportion of these trees having a given quartet (concordance factor: CF), for all quartets or for a sample of quartets. Optional arguments include:\n\nquartetfile: name of text file with list of 4-taxon subsets to be analyzed. If none is specified, the function will list all possible 4-taxon subsets.\nwhichQ=\"rand\": to choose a random sample of 4-taxon subsets\nnumQ: size of random sample (ignored if whichQ is not set to \"rand\")\nwriteTab=false: does not write the observedCF to a table (default true)\nCFfile: name of file to save the observedCF (default tableCF.txt)\nwriteQ=true: save intermediate files with the list of all 4-taxon subsets and chosen random sample (default false).\nwriteSummary: write descriptive stats of input data (default: true)\nnexus: if true, it assumes the gene trees are written in nexus file (default: false)\n\nSee also: PhyloNetworks.countquartetsintrees, which uses a much faster algorithm; readtableCF to read a table of quartet CFs directly.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SNaQ.snaq!-Tuple{HybridNetwork, DataCF}","page":"Public","title":"SNaQ.snaq!","text":"snaq!(T::HybridNetwork, d::DataCF)\n\nEstimate the network (or tree) to fit observed quartet concordance factors (CFs) stored in a DataCF object, using maximum pseudo-likelihood. A level-1 network is assumed. The search starts from topology T, which can be a tree or a network with no more than hmax hybrid nodes. The function name ends with ! because it modifies the CF data d by updating its attributes expCF: CFs expected under the network model. It does not modify T. The quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.\n\nOutput:\n\nestimated network in file .out (also in .log): best network overall and list of networks from each individual run.\nthe best network and modifications of it, in file .networks. All networks in this file have the same undirected topology as the best network, but have different hybrid/gene flow directions. These other networks are reported with their pseudo-likelihood scores, because non-identifiability issues can cause them to have very similar scores, and because SNaQ was shown to estimate the undirected topology accurately but not the direction of hybridization in cases of near non-identifiability.\nif any error occurred, file .err provides information (seed) to reproduce the error.\n\nThere are many optional keyword arguments, including\n\nhmax (default 1): maximum number of hybridizations allowed\npropQuartets (default 1): the proportion of observed quartet concordance factors in d to use when calculating network pseudo-likelihoods. Smaller values will lead to faster method runtime but may come at the expense of accuracy if lowered too far.\nprobQR (default 0): the probability at any given step to use weighted random sampling of quartets when deciding where to make topological moves when proposing the next candidate network.\nverbose (default false): if true, print information about the numerical optimization\nruns (default 10): number of independent starting points for the search\noutgroup (default none): outgroup taxon to root the estimated topology at the very end\nfilename (default \"snaq\"): root name for the output files (.out, .err). If empty (\"\"), files are not created, progress log goes to the screen only (standard out).\nseed (default 0 to get it from the clock): seed to replicate a given search\nprobST (default 0.3): probability to start from T at each given run. With problability 1-probST, the search is started from an NNI modification of T along a tree edge with no hybrid neighbor, with a possible modification of one reticulation if T has one.\nupdateBL (default true): If true and if T is a tree, the branch lengths in T are first optimized roughly with updateBL! by using the average CF of all quartets defining each branch and back-calculating the coalescent units.\n\nThe following optional keyword arguments control when to stop the optimization of branch lengths and γ's on each individual candidate network. Defaults are in parentheses:\n\nftolRel (1e-6) and ftolAbs (1e-6): relative and absolute differences of the network score between the current and proposed parameters,\nxtolRel (1e-2) and xtolAbs (1e-3): relative and absolute differences between the current and proposed parameters.\n\nGreater values will result in a less thorough but faster search. These parameters are used when evaluating candidate networks only. The following optional keyword arguments control when to stop proposing new network topologies:\n\nNfail (75): maximum number of times that new topologies are proposed and rejected (in a row).\nliktolAbs (1e-6): the proposed network is accepted if its score is better than the current score by at least liktolAbs.\n\nLower values of Nfail and greater values of liktolAbs and ftolAbs would result in a less thorough but faster search.\n\nAt the end, branch lengths and γ's are optimized on the last \"best\" network with different and very thorough tolerance parameters: 1e-12 for ftolRel, 1e-10 for ftolAbs, xtolRel, xtolAbs.\n\nThe following optional keyword arguments are used to identify and exclude uninformative quartets. Uninformative quartets are those with concordance factors sufficiently close to the expected concordance factors from the star tree (one-third for all topologies).  Default parameters are are in parentheses:\n\nqinfTest (false): if true, then look for uninformative quartets to discard.\nqtolAbs (1e-4): The tolerance for identifying uninformative concordance factors. Uninformative concordance factors are (1/3)±qtolAbs\n\nSee also: topologymaxQpseudolik! to optimize parameters on a fixed topology, and topologyQpseudolik! to get the deviance (pseudo log-likelihood up to a constant) of a fixed topology with fixed parameters.\n\nReferences:\n\nClaudia Solís-Lemus and Cécile Ané (2016). Inferring phylogenetic networks with maximum pseudolikelihood under incomplete lineage sorting. PLoS Genetics 12(3):e1005896\n\nKolbow, N, Kong, K, Chafin, T, Justison, J, Ane, C, Solis-Lemus, C (2025). SNaQ.jl: Improved scalability for phylogenetic network inference.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SNaQ.summarizedataCF-Tuple{DataCF}","page":"Public","title":"SNaQ.summarizedataCF","text":"summarizedataCF(d::DataCF)\n\nfunction to summarize the information contained in a DataCF object. It has the following optional arguments:\n\nfilename: if provided, the summary will be saved in the filename, not to screen\npc (number between (0,1)): threshold of percentage of missing genes to identify 4-taxon subsets with fewer genes than the threshold\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SNaQ.topologyQpseudolik!-Tuple{HybridNetwork, DataCF}","page":"Public","title":"SNaQ.topologyQpseudolik!","text":"topologyQpseudolik!(net::HybridNetwork, d::DataCF)\n\nCalculate the quartet pseudo-deviance of a given network/tree for DataCF d. This is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.\n\nNote that the network's parameters (edge lengths and γs) are not optimized. So be careful if net does not have all internal branch lengths specified, because then the pseudolikelihood will be meaningless. See topologymaxQpseudolik! if you want branch lengths and numerical parameters optimized on the given network.\n\nThe fscore field of the network is updated to contain the pseudo-deviance, and d is updated with the expected concordance factors under the input network.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SNaQ.topologymaxQpseudolik!-Tuple{HybridNetwork, DataCF}","page":"Public","title":"SNaQ.topologymaxQpseudolik!","text":"topologymaxQpseudolik!(\n    net::HybridNetwork,\n    d::DataCF;\n    verbose = true,\n    ftolRel = 1e-6,\n    ftolAbs = 1e-6,\n    xtolRel = 1e-2,\n    xtolAbs = 1e-3\n)\n\nEstimate the branch lengths and inheritance probabilities (γ's) for a given network topology. The network is not modified, only the object d is, with updated expected concordance factors.\n\nOuput: new network, with optimized parameters (branch lengths and gammas). The maximized quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0. This is also an attribute of the network, which can be accessed with loglik(net).\n\nOptional arguments:\n\nverbose: if true, information on the numerical optimization is printed to screen\nftolRel, ftolAbs, xtolRel, xtolAbs: absolute and relative tolerance values for the pseudo-deviance function (f) and the parameters (x).\n\nThe default tolerance values are quite lenient, for faster running time. They are more lenient than those used in snaq!, so we can expect that snaq! returns a better (lower) score for the same network topology. It is highly recommended to use more stringent value than the default, for example 1e-12 for ftolRel, and 1e-10 for ftolAbs, xtolRel, xtolAbs to match those in snaq!.\n\nTo further optimize branch lengths and γs, another strategy is the run the topologymaxQpseudolik! multiple times, because each time the edge parameters in the network are improved, and re-starting a search from a good place leads to finding even better edge parameter values. If snaq! finds a better score for the given network topology, then using this strategy (effectively used by snaq! when optimizing edge parameters at each trial) and using stringent tolerances should eliminate the difference.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SNaQ.DataCF","page":"Public","title":"SNaQ.DataCF","text":"DataCF\n\ntype that contains the following attributes:\n\nquartet (vector of Quartets)\nnumQuartets\ntree (vector of trees: empty if a table of CF was input instead of list of trees)\nnumTrees (-1 if a table CF was input instead of list of trees)\nrepSpecies (taxon names that were repeated in table of CF or input gene trees: used inside snaq for multiple alleles case)\n\nThe list of Quartet may be accessed with the attribute .quartet. If the input was a list of trees, the HybridNetwork's can be accessed with the attribute .tree. For example, if the DataCF object is named d, d.quartet[1] will show the first quartet and d.tree[1] will print the first input tree.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SNaQ.Quartet","page":"Public","title":"SNaQ.Quartet","text":"Quartet\n\ntype that saves the information on a given 4-taxon subset. It contains the following attributes:\n\nnumber: integer\ntaxon: vector of taxon names, like t1 t2 t3 t4\nobsCF: vector of observed CF, in order 12|34, 13|24, 14|23\nlogPseudoLik: log pseudo-likelihood of the quartet. 0.0 by default\nngenes: number of gene trees used to compute the observed CF; -1.0 if unknown\nqnet: QuartetNetwork, which saves the expCF after snaq estimation to emphasize that the expCF depend on a specific network, not the data\ndeltaCF: The sum of absolute differences between observed and expected CFs\nsampled: A boolean denoting whether the quartet is used in computing the likelihood\nuninformative: A boolean denoting whether the quartet is not sampling due to being uninformative\n\nsee also: PhyloNetworks.QuartetT for quartet with data of user-defined type T, using a mapping between quartet indices and quartet taxa.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"info: Important Note:\nThis documentation pertains to SNaQ v1.1 and may differ from the specific implementation originally described in Solís-Lemus & Ané (2016). See documentation SNaQ v1.0  for the original implementation.","category":"page"},{"location":"man/fixednetworkoptim/#Candidate-networks","page":"Candidate networks","title":"Candidate networks","text":"","category":"section"},{"location":"man/fixednetworkoptim/#Optimizing-parameters-for-a-given-network","page":"Candidate networks","title":"Optimizing parameters for a given network","text":"","category":"section"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"For a given network topology, we can optimize the branch lengths and inheritance probabilities (γ) with the pseudolikelihood. This is useful if we have a few candidate networks to compare. Each network can be optimized individually, and the network with the best pseudolikelihood can be chosen.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"The score being optimized is a pseudo-deviance, i.e. a multiple of the negative log pseudo-likelihood up to an additive constant (the lower the better; a pseudo-deviance of 0 corresponds to a perfect fit).","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"Following our example in Estimating a network, we can optimize parameters on the true network (the one originally used to simulate the data).  Given a table of CFs and a network, the function topologymaxQpseudolik! returns the same network topology but with optimized branch lengths and inheritance values:","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"truenet = readnewick(\"((((D:0.4,C:0.4):4.8,((A:0.8,B:0.8):2.2)#H1:2.2::0.7):4.0,(#H1:0::0.3,E:3.0):6.2):2.0,O:11.2);\");\nnet1alt = topologymaxQpseudolik!(truenet, raxmlCF);\nwritenewick(net1alt, round=true)\nloglik(net1alt) # pseudo-deviance actually: the lower the better","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"using PhyloPlots, RCall\nR\"name <- function(x) file.path('..', 'assets', 'figures', x)\" # hide\nR\"svg(name('truenet_opt.svg'), width=4, height=4)\" # hide\nR\"par\"(mar=[0,0,0,0])\nplot(net1alt, showgamma=true);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"(Image: truenet_opt)","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"We get a score of 29.786, which is comparable to the score of the SNaQ network (net1: 28.315), especially compared to the score of the best tree (net0: 53.532). This begs the question: is the true network within the \"range\" of uncertainty? We can run a Bootstrap analysis to measure uncertainty in our network inference.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"For a more thorough optimization, we could change the arguments for the tolerances (ftolRel and xtolAbs) used to determine when the parameters are optimized and the search stops (but the optimization will take longer). It makes no difference on this small data set.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"net1par = topologymaxQpseudolik!(truenet, raxmlCF, ftolRel=1e-10, xtolAbs=1e-10)\nloglik(net1par) # pseudo-deviance, actually: the lower the better","category":"page"},{"location":"man/fixednetworkoptim/#Network-score-with-no-optimization","page":"Candidate networks","title":"Network score with no optimization","text":"","category":"section"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"For a network with given branch lengths and γ heritabilies, we can compute the pseudolikelihood (well, a pseudo-deviance) with:","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"topologyQpseudolik!(truenet,raxmlCF);\nloglik(truenet) # again, pseudo-deviance","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"This function is not maximizing the pseudolikelihood, it is simply computing the pseudolikelihood (or deviance) for the given branch lengths and probabilities of inheritance. At the moment, both of these functions require that the given network is of level 1 (cycles don't overlap).","category":"page"},{"location":"man/fixednetworkoptim/#Candidate-networks-compatible-with-a-known-outgroup","page":"Candidate networks","title":"Candidate networks compatible with a known outgroup","text":"","category":"section"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"If the network was estimated via snaq!, it might turn out to be impossible to root our estimated network with a known outgroup. At this time, snaq! does not impose any rooting constraint on the network: the search for the lowest score considers all level-1 networks, including those that are incompatible with a known outgroup. (The monophyly of outgroups is not imposed either, like in many other methods.)","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"If the estimated network cannot be rooted with the known outgroup, we can check the .networks output file for a possible alternative network. It has a list of networks that are slight modifications of the best network, where the modifications changed the direction of one reticulation at a time. For each modified network, the score was calculated. So if we find in this list a modified network that has a score close to that of the best network, and that can be re-rooted with our known root position, then this modified network is a better candidate than the network with the best score.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"Below is what the net1.networks file looks like, after performing the analysis in the section Network estimation. Scroll to the right to see the scores.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"(C,D,((O,(E,#H7:::0.19558838614943078):0.31352437658618976):0.6640664399202987,(B,(A)#H7:::0.8044116138505693):10.0):10.0);, with -loglik 28.31506721890958 (best network found, remaining sorted by log-pseudolik; the smaller, the better)\n(C,D,((O,(E)#H7:::0.8150784689693145):0.9336405757682176,(B,(A,#H7:::0.18492153103068557):0.25386142779877724):1.8758156446611114):10.0);, with -loglik 31.535560380783814\n(B,#H7:9.90999345612101::0.2555404440833535,(A,(E,(O,((C,D):10.0)#H7:0.3419231810962026::0.7444595559166465):0.19994859441332047):2.5014911511063644):0.7957621793330066);, with -loglik 56.64548310161462\n(C,D,((O,(E,((B)#H7:::0.7957543284159452,A):4.786202415937916):0.004527712280136759):1.7952610454570868,#H7:::0.20424567158405482):10.0);, with -loglik 67.17775727492258\n(C,D,(#H7:::0.32947301811471164,(B,(A,(E,(O)#H7:::0.6705269818852884):1.371799259141243):0.0):6.397073999864152):7.677245926003807);, with -loglik 199.11401961057143","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"We can read this file and look at its list of networks like this:","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"file = \"net1.networks\";\n# or use the example file available with the package:\nfile = joinpath(dirname(pathof(SNaQ)), \"..\",\"examples\",\"net1.networks\");\nnetlist = readmultinewick(file) # read the full list of networks in that file","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"Next, we would like to extract the network scores from the file. Below is some code for doing this in julia","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"score_in_string = read(file, String); # read the file as a single string\nscore_in_string = (x-> x[1]).(collect(eachmatch(r\"with -loglik ([0-9]+.[0-9]+)\",score_in_string))); # find all occurences of the loglik scores\nscores = parse.(Float64, score_in_string); # parse those matches into numbers\n\n# next: update the \"loglik\" of each network with the score read from the file\nfor i in eachindex(netlist)\n   netlist[i].fscore = scores[i]\n   println(\"net $i in the list: score = \",scores[i])\nend","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"The first network in the list is the best network returned by snaq!. We see that the second network has a score that's not too far, but the other networks have worse scores. The best network and its best modification (second network in the list) are shown below. We chose to show edge numbers, to use them later to re-root the networks.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"R\"svg(name('fixednetworkoptim_othernets1.svg'), width=7, height=4)\" # hide\nR\"layout(matrix(1:2,1,2))\"; # hide\nR\"par\"(mar=[0,0,0,0]) # hide\nplot(netlist[1], showgamma=true, showedgenumber=true, tipoffset=0.1);\nR\"mtext\"(\"best net, score=28.3\", line=-1);\nplot(netlist[2], showgamma=true, showedgenumber=true, tipoffset=0.1);\nR\"mtext\"(\"direction modified, score=31.5\", line=-1);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"(Image: othernets before reroot)","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"Now imagine that our outgroup is taxon A.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"Best network: we would get a RootMismatch error if we tried to set the root on the external edge 9 to A, with rootatnode!(netlist[1], \"A\") (see the PhyloNetworks guide Does the root conflict with the direction of a reticulation?). But we could root the best network on the major parent edge to A, edge 10 (rooted network on the left below).","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"R\"svg(name('fixednetworkoptim_othernets2.svg'), width=7, height=7)\" # hide\nR\"layout(matrix(c(1,4,2,3),2,2))\"; # hide\nR\"par\"(mar=[0,0,0.5,0]) # hide\nrootonedge!(netlist[1], 10); # root best net to make A outgroup\nrotate!(netlist[1], -4); # to 'un-cross' edges\nrotate!(netlist[1], -6);\nrotate!(netlist[1], -5);\nplot(netlist[1], showgamma=true, tipoffset=0.1);\nR\"mtext\"(\"best net, score=28.3\", line=-1);\nglobal_logger(NullLogger()); # hide\nrootatnode!(netlist[2], \"A\"); # net with modified direction: first way to make A outgroup\nglobal_logger(baselogger);   # hide\nrotate!(netlist[2], -4) # to 'un-cross' edges\nrotate!(netlist[2], -6)\nplot(netlist[2], showgamma=true, tipoffset=0.1);\nR\"mtext\"(\"second best in list, score=31.5\\nrequires unsampled population\", line=-2);\nrootonedge!(netlist[2], 10) # net with modified direction: second way to make A outgroup\nfor i in [9,-7] rotate!(netlist[2], i); end; # to 'un-cross' edges\nplot(netlist[2], showgamma=true, tipoffset=0.1);\nR\"mtext\"(\"second best in list, score=31.5\\ndifferent root position\", line=-2);\nR\"dev.off()\"; # hide\nnothing # hide","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"(Image: othernets after reroot)","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"For the second best network in our list, there are 2 ways to root it with A. These 2 options give quite different rooted versions of the network:","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"On the external edge 8 to A (top right). This requires the existence of an unsampled taxon, sister to BDCOE, that would have contributed to introgression into an ancestor of E.\nOn its parent edge 10 (bottom right).","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"A is an outgroup in both rootings, but the second option is more parsimonious, in the sense that it does not outright require the existence of a \"ghost\" taxon: a taxon that went extinct after the introgression, or that is unsampled.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"This second rooted version is consistent with 2 possibilities. It could arise either from   (a) an unsampled taxon sister to A that contributed to introgression, or   (b) a direct ancestor of A could have contributed to the introgression into the ancestor of E.   Case (a) stipulates the existence of an unsampled (\"ghost\") taxon, but case (b) does not require any unsampled taxon.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"These two possibilities differ in the length of their gene flow edge (light blue, here with γ=0.185). If gene flow came from an unsampled taxon under case (a), this edge would have positive length, in calendar time. If gene flow came from a direct ancestor of A under case (b), the gene flow edge would have length 0.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"Edge lengths from SNaQ should be interpreted with caution to distinguish between the two possibilities because:","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"edge lengths estimated with SNaQ are in coalescent units instead of calendar time, and necessarily include estimation error;\nan edge with a true length of 0 may be estimated to have a non-zero length in coalescent units due to errors in estimated gene trees, to help explain gene tree discordance;\nan incorrect topology may result in edges of estimated length 0;\nand some edge lengths are not identifiable from quartet concordance factors anyway.","category":"page"},{"location":"man/fixednetworkoptim/","page":"Candidate networks","title":"Candidate networks","text":"To distinguish between these possibilities, models that separate calendar time, substitution rate, and population size can be useful. Using stronger assumptions than SNaQ (e.g. a molecular clock), the rooted network and branch lengths may be identifiable, so networks with / without unsampled taxa may be distinguished. See for example Zhang et al. 2024, who used BPP. Note that the model named \"MSci\" in BPP is exactly the same as the network multispecies coalescent, and is typically named NMSC in most papers.","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"info: Important Note:\nThis documentation pertains to SNaQ v1.1 and may differ from the specific implementation originally described in Solís-Lemus & Ané (2016). See documentation SNaQ v1.0  for the original implementation.","category":"page"},{"location":"man/parallelcomputation/#Improving-runtimes","page":"Improving runtimes","title":"Improving runtimes","text":"","category":"section"},{"location":"man/parallelcomputation/#Parallel-runs","page":"Improving runtimes","title":"Parallel runs","text":"","category":"section"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"For network estimation, multiple runs can done in parallel. For example, if your machine has 4 or more processors (or cores), you can tell julia to use 4 processors by starting julia with julia -p3, or by starting julia the usual way (julia) and then adding processors with:","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"using Distributed\naddprocs(3)","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"note: Note\nThe -p argument for julia denotes additional processors. So, julia -p3 will start Julia with 4 processors.","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"If we load a package (using SNaQ) before adding processors, then we need to re-load it again so that all processors have access to it:","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"@everywhere using PhyloNetworks, SNaQ","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"After that, running the snaq!(...) command will use different cores for the different independent runs specified by  optional runs argument, as processors become available.","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"When running bootsnaq, the analysis of each bootstrap replicate will use multiple cores to parallelize separate runs of that particular bootstrap replicate. You may parallelize things further by running bootsnaq multiple times (on separate machines for instance), each time for a small subset of bootstrap replicates, and with a different seed each time.","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"We may tell julia to add more processors than our machine has, but we will not receive any performance benefits. At any time during the julia session, nworkers() tells us how many worker processors julia has access to.","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"Below is an example of how to use a cluster, to run many independent snaq! searches in parallel on a cluster running the slurm job manager (other managers would require a different, but similar submit file). This example uses 2 files:","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"a julia script file, to do many runs of snaq! in parallel, asking for many cores (default: 10 runs, asking for 10 cores). This julia script can take arguments: the maximum allowed number of hybridizations hmax, and the number of runs (to run 50 runs instead of 10, say).\na submit file, to launch the julia script.","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"First: the example julia script, below or here, is assumed (by the submit file) to be called runSNaQ.jl. It uses a starting tree that is assumed to be available in a file named astraltree.tre, but that could be modified (to use a network with h=1 to start the search with hmax=2 for instance). It also assumes that the quartet concordance factor data are in file tableCF_speciesNames.csv. Again, this file name should be adjusted. To run this julia script for 50 runs and hmax=3, do julia runSNaQ.jl 3 50.","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"#!/usr/bin/env julia\n\n# file \"runSNaQ.jl\". run in the shell like this in general:\n# julia runSNaQ.jl hvalue nruns\n# example for h=2 and default 10 runs:\n# julia runSNaQ.jl 2\n# or example for h=3 and 50 runs:\n# julia runSNaQ.jl 3 50\n\nlength(ARGS) > 0 ||\n    error(\"need 1 or 2 arguments: # reticulations (h) and # runs (optional, 10 by default)\")\nh = parse(Int, ARGS[1])\nnruns = 10\nif length(ARGS) > 1\n    nruns = parse(Int, ARGS[2])\nend\noutputfile = string(\"net\", h, \"_\", nruns, \"runs\") # example: \"net2_10runs\"\nseed = 1234 + h # change as desired! Best to have it different for different h\n@info \"will run SNaQ with h=$h, # of runs=$nruns, seed=$seed, output will go to: $outputfile\"\n\nusing Distributed\naddprocs(nruns)\n@everywhere using SNaQ\nnet0 = readnewick(\"astraltree.tre\");\nusing DataFrames, CSV\ndf_sp = CSV.read(\"tableCF_speciesNames.csv\", DataFrame; pool=false);\nd_sp = readtableCF!(df_sp);\nnet = snaq!(net0, d_sp, hmax=2, filename=outputfile, seed=seed, runs=nruns)","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"When julia is called on a script, whatever comes after \"julia scriptname\" is given to julia in an array of values. This array is called ARGS. So if we call a script like this: julia runSNaQ.jl 2 then the script will know the arguments through ARGS, which would contain a single element, \"2\". This first element is just a string, at this stage. We want to use it as a number, so we need to ask julia to parse the string into an integer.","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"Second: we need a \"submit\" file to ask a job scheduler like slurm to submit our julia script to a cluster. In the submit file below, the first 5 lines set things up for slurm. They are most likely to be specific to your cluster. The main idea here is to use a slurm \"array\" from 0 to 3, to run our julia script multiple times, 4 times actually: from hmax=0 to hmax=3. Each would do 30 runs (and each would be allocated 30 cores in the submit script below). Then log out of the cluster and go for coffee.","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"#!/bin/bash\n#SBATCH -o path/to/slurm/log/file/runsnaq_slurm%a.log\n#SBATCH -J runsnaq\n#SBATCH --array=0-3\n#SBATCH -c 30\n## --array: to run multiple instances of this script,\n##          one for each value in the array.\n##          1 instance = 1 task\n## -J job name\n## -c number of cores (CPUs) per task\n\necho \"slurm task ID = $SLURM_ARRAY_TASK_ID used as hmax\"\necho \"start of SNaQ parallel runs on $(hostname)\"\n# finally: launch the julia script, using Julia executable appropriate for slurm, with full paths:\n/workspace/software/bin/julia --history-file=no -- runSNaQ.jl $SLURM_ARRAY_TASK_ID 30 > net${SLURM_ARRAY_TASK_ID}_30runs.screenlog 2>&1\necho \"end of SNaQ run ...\"","category":"page"},{"location":"man/parallelcomputation/#Parallel-quartet-likelihood","page":"Improving runtimes","title":"Parallel quartet likelihood","text":"","category":"section"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"This section describes the functionalities for scalability improvements in Kolbow et al 2025 for SNaQ (v1.1).","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"Each step of optimization involves computing the likelihood of each quartet. Since SNaQ treats quartet likelihoods as independent, their likelihoods can be computed in parallel with multi-threading.  To enable multi-threading, the user needs to specify how many threads are avaliable when starting a Julia session with the --threads flag:","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"julia --threads=8 #use 8 threads","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"SNaQ then automatically multi-threads quartet likelihoods, if given the opportunity.  Setting --threads=auto uses all avaliable CPU threads.","category":"page"},{"location":"man/parallelcomputation/#Quartet-subsampling","page":"Improving runtimes","title":"Quartet subsampling","text":"","category":"section"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"For a network with N taxa, there are binomN4 different quartets, meaning that the complexity of likelihood computation balloons quartically with respect to the number of taxa.  In cases where the number of taxa causes network estimation to be prohibitively slow, we implemented a strategy that only uses a fraction of all quartets when computing the likelihood. For a network with binomN4 quartets, the optional propQuartets argument can be used to randomly sample lceil binomN4 cdot propQuartets rceil quartets. Although we lose some information when subsampling quartets, using propQuartets as low as 0.5 has been shown to not signifcantly decrease accuracy.","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"We can run the same analysis as the Estimating a network section and comapre the two networks when we use only a fraction of the quartets. ","category":"page"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"raxmltrees = joinpath(dirname(pathof(SNaQ)), \"..\",\"examples\",\"raxmltrees.tre\");\nraxmlCF = readtrees2CF(raxmltrees)\nastralfile = joinpath(dirname(pathof(SNaQ)), \"..\",\"examples\",\"astral.tre\");\nastraltree = readmultinewick(astralfile)[102] # 102th tree: last tree here\n\nnet0 = snaq!(astraltree,raxmlCF, hmax=0, filename=\"net0\", propQuartets=0.75)","category":"page"},{"location":"man/parallelcomputation/#Removing-uninformative-quartets","page":"Improving runtimes","title":"Removing uninformative quartets","text":"","category":"section"},{"location":"man/parallelcomputation/","page":"Improving runtimes","title":"Improving runtimes","text":"We can further reduce computational costs with minimal detriment to accuracy by ignoring uniformative quartets. A star tree would give concordance factors of frac13 for all quartet topologies, thus, quartets with CFs near frac13 may not be informative of the overall species topology. We can check for and remove uninformative quartets by setting  the optional keyword argument qinfTest to true. Any quartets with concordance factors sufficiently close to frac13 will be removed when  computing the composite likelihood.  Further, the optional keyword argument qtolAbs can be used to specify the tolerence for determining what concordance factors are \"close enough\" to frac13.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"info: Important Note:\nThis documentation pertains to SNaQ v1.1 and may differ from the specific implementation originally described in Solís-Lemus & Ané (2016). See documentation SNaQ v1.0  for the original implementation.","category":"page"},{"location":"man/multiplealleles/#Multiple-alleles-per-species","page":"Multiple alleles","title":"Multiple alleles per species","text":"","category":"section"},{"location":"man/multiplealleles/#Between-species-4-taxon-sets","page":"Multiple alleles","title":"Between-species 4-taxon sets","text":"","category":"section"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"The default setting for SNaQ considers that each allele in a gene tree corresponds to a taxon (a tip) in the network. If instead each allele/individual can be mapped confidently to a species, and if only the species-level network needs to be estimated, then the following functions can be used:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"using CSV, DataFrames\nmappingfile = joinpath(dirname(pathof(SNaQ)), \"..\",\"examples\",\n    \"mappingIndividuals.csv\");\ntm = CSV.read(mappingfile, DataFrame) # taxon map as a data frame\ntaxonmap = Dict(r[:individual] => r[:species] for r in eachrow(tm)) # as dictionary","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"The mapping file can be a text (or csv) file with two columns (at least): one for the individuals, named allele or individual, and one column containing the species names, named species. Each row should map an allele name to a species name. Next, read in the gene trees and calculate the quartet CFs at the species level:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"genetreefile = joinpath(dirname(pathof(SNaQ)), \"..\",\"examples\",\n    \"genetrees_alleletips.tre\");\ngenetrees = readmultinewick(genetreefile);\nsort(tiplabels(genetrees[1])) # multiple tips in species S1\ndf_sp = tablequartetCF(countquartetsintrees(genetrees, taxonmap;\n    showprogressbar=false)...);\nkeys(df_sp)  # columns names\ndf_sp[:qind] # quartet index\ndf_sp[:t1]   # name of first taxon in each quartet\ndf_sp[:CF12_34] # concordance factor for split taxa 12 vs 34","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"Now df_sp is a table (technically, a named tuple) containing the quartet concordance factors at the species level only, that is, considering sets made of 4 distinct species, even if the gene trees may have multiple alleles from the same species. For 4 distinct species A,B,C,D, all alleles from each species (A etc.) will be used to calculate the quartet CF. If a given gene tree has n_a alleles from a, n_b alleles from b etc., then each set of 4 alleles is given a weight of 1/(n_a n_b n_c n_d) to calculated of the CF for A,B,C,D (such that the total weight from this particular gene trees is 1). It is safe to save this data frame, then use it for snaq! like this:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"CSV.write(\"tableCF_species.csv\", df_sp);   # to save the table to a file\nd_sp = readtableCF(\"tableCF_species.csv\"); # \"DataCF\" object for use in snaq!\nsummarizedataCF(d_sp)","category":"page"},{"location":"man/multiplealleles/#Within-species-4-taxon-sets","page":"Multiple alleles","title":"Within-species 4-taxon sets","text":"","category":"section"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"Four-taxon sets involving 2 individuals per species can provide more information about the underlying network, including external branch length in coalescent units. However, snaq! runs more slowly when using this extra information.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"To get quartet CFs from sets of 4 individuals in which 2 individuals are from the same species, the following functions should be used, where the mapping file can be a text (or csv) file with two columns named allele (or individual) and species, mapping each allele name to a species name.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"q,t = countquartetsintrees(genetrees);\ndf_ind = DataFrame(tablequartetCF(q,t)); # no mapping: CFs across individuals\nfirst(df_ind, 5) # to see the first 5 rows","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"Now df_ind is the table of concordance factors at the level of individuals. In other words, it lists CFs using one row for each set of 4 alleles/individuals.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"Warning: This procedure requires that all alleles from the same individual are given the same name (the individual's 'name') across all genes for which that individual was sequenced.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"Next, we use mapallelesCFtable to get these data as quartet concordance factors at the species level in df_sp: with the allele names replaced by the appropriate species names.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"CSV.write(\"tableCF_individuals.csv\", df_ind);  # to save to a file\ndf_sp = mapallelesCFtable(mappingfile, \"tableCF_individuals.csv\";\n    columns=2:5); # taxon names are in columns 2 through 5, not default 1-4\nnrow(df_sp)       # 35 quartets of individuals\nfirst(df_sp, 6)   # first 6 rows of data frame","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"The warning above, after creating df_sp, is because our mapping file does not list species S2 through S5. We did not need to list them because we have a single individual in each of these species. So we can safely ignore the warning. We will just need to make sure that our starting tree, when we run SNaQ, has the same (unmapped) names, here S2-S5.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"The command below modifies df_sp to delete rows that are uninformative about between-species relationships, such as rows containing 3 or 4 individuals from the same species (e.g. rows 1, 2 and 6: they contain S1 three times); and creates d_sp, an object of type DataCF at the species level, that we can use later as input for networks estimation with snaq!.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"d_sp = readtableCF!(df_sp, mergerows=true); # DataCF object\nnrow(df_sp) # 31 quartets of individuals informative between species","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"note: Note\nFor a four-taxon set A,B,C,D, all the individuals from A, B, C and D are considered, say (a1,b1,c1,d1), (a2,b1,c1,d1), (a1,b2,c1,d1), (a2,b2,c1,d1) and so on. The CFs of these 4-taxon sets are averaged together to obtain the CFs at the species level. This procedures gives more weight to genes that have many alleles (because they contribute to more sets of 4 individuals) and less weight to genes that have few alleles.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"Before we run SNaQ, it is safe to save the concordance factor of species quartets, which can be calculated by averaging the CFs of quartets of individuals from the associated species:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"df_sp_ave = DataFrame(tablequartetCF(d_sp))  # CFs averaged across individuals\nCSV.write(\"CFtable_species.csv\", df_sp_ave); # save to file","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"Some quartets have the same species repeated twice, representing cases when 2 of the 4 individuals came from the same species. These quartets, with repeated species, are informative about the population size of extant populations, i.e. about the lengths of external branches in coalescent units.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"The main difference between this section compared to the previous section on Between-species 4-taxon sets is that quartets with 2 individuals from the same species are included here, such as a1,a2,b1,c1. Also, the weighting of quartets is different. Here, genes with more alleles are given more weight.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"now we can run snaq!:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"net = snaq!(T_sp, d_sp);","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"where T_sp should be a starting topology with one tip per species, labelled with the same species names as the names used in the mapping file.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"If snaq! takes too long that way, we can try a less ambitious estimation that does not estimate the external branch lengths, that is, without using quartets that have 2 individuals from the same species. To do so, we can use the quartet concordance factors at the species level, but filter out the quartets with one (or more) species repeated, such as these below:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"first(df_sp_ave, 3) # some quartets have the same species twice","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"Filtering them out can be done as in the first section (Between-species 4-taxon sets) to give equal weight to all genes, or as shown below to give more weight to genes that have more alleles. We first define a helper function to identify which rows we want to get rid of.","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"first(df_sp_ave, 3) # some quartets have the same species twice\n\"\"\"\n    hasrep\n\nReturn true if a row (4-taxon set) has a \"repeated\" species, that is, a species\nwhose name ends with \"__2\". Otherwise, return false.\n\nWarning: this function assumes that taxon names are in columns\n\"t1\", \"t2\", \"t3\", \"t4\". For data frames with different column names,\ne.g. \"taxon1\", \"taxon2\" etc., simply edit the code below by replacing\n`:t1` by `:taxon1` (or the appropriate column name in your data).\n\"\"\"\nfunction hasrep(row)\n    occursin(r\"__2$\", row[:t1]) || occursin(r\"__2$\", row[:t2]) ||\n    occursin(r\"__2$\", row[:t3]) || occursin(r\"__2$\", row[:t4])\nend; # this function is used on the next line\ndf_sp_reduced = filter(!hasrep, df_sp_ave) # removes rows with repeated species\nCSV.write(\"CFtable_species_norep.csv\", df_sp_reduced); # to save to file\nd_sp_reduced = readtableCF(df_sp_reduced) # DataCF object, for input to snaq!","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"and now we can run snaq! on the reduced set of quartets without repeats, which should be faster:","category":"page"},{"location":"man/multiplealleles/","page":"Multiple alleles","title":"Multiple alleles","text":"net = snaq!(T_sp, d_sp_reduced);","category":"page"},{"location":"man/error_reporting/","page":"Error reporting","title":"Error reporting","text":"info: Important Note:\nThis documentation pertains to SNaQ v1.1 and may differ from the specific implementation originally described in Solís-Lemus & Ané (2016). See documentation SNaQ v1.0  for the original implementation.","category":"page"},{"location":"man/error_reporting/#SNaQ-error-reporting","page":"Error reporting","title":"SNaQ error reporting","text":"","category":"section"},{"location":"man/error_reporting/","page":"Error reporting","title":"Error reporting","text":"Please report any bugs and errors by opening an issue. The easiest way to provide information on the error is by checking the .err file, which will show the number of runs that failed and the corresponding seed to replicate the run. In case of an error, the .err file might look like: Total errors: 1 in seeds [4545]. This file and any information that will help replicating the error will be immensely helpful to fix the error/bug.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"info: Important Note:\nThis documentation pertains to SNaQ v1.1 and may differ from the specific implementation originally described in Solís-Lemus & Ané (2016). See documentation SNaQ v1.0  for the original implementation.","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/#Install-Julia","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"To install Julia, follow instructions here.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Julia code is compiled just-in-time, meaning that the first time you run a function, it will be compiled at that moment. So, please be patient! Future calls to the function will be much faster. Trying out toy examples for the first calls is a good idea.","category":"page"},{"location":"man/installation/#Install-SNaQ","page":"Installation","title":"Install SNaQ","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"To install the package, type inside Julia:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"SNaQ\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"If you already installed the package and want the latest registered version, do the following (which will update all of your packages):","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Pkg.update()","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"It is important to update the package regularly as it is undergoing constant development.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Pkg.update() will install the latest registered version, but there could be other improvements in the main branch of the repository. If you want to update to the latest unregistered version of the package, you can do Pkg.add(PackageSpec(name=\"SNaQ\", rev=\"main\")) just beware that the latest changes could be not as robust. If you want to go back to the registered package, you can do Pkg.free(\"SNaQ\").","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Similarly, you can pin a version of the package Pkg.pin(\"SNaQ\") so that Pkg.update() will not modify it. You can always free a pinned package with Pkg.free(\"SNaQ\"). More on package management here.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The SNaQ package has dependencies like PhyloNetworks (see the Project.toml file for the full list), but everything is installed automatically.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"PhyloPlots has utilities to visualize networks, and for interoperability, such as to export networks to R (which can then be plotted via R). To install:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"PhyloNetworks\")\nPkg.add(\"PhyloPlots\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"PhyloPlots also depends on PhyloNetworks, and has further dependencies like RCall","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"To check that your installation worked, type this in Julia to load the package. This is something to type every time you start a Julia session:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using PhyloNetworks\nusing SNaQ","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"You can see a list of all the functions with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"varinfo(SNaQ)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"and press ? inside Julia to switch to help mode, followed by the name of a function (or type) to get more details about it.","category":"page"},{"location":"man/installation/#Test-example","page":"Installation","title":"Test example","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"We show here small examples on how to get more info on an object, what's its type, and how to manipulate objects.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"For example, let's take an object raxmlCF created from reading in some data in the form of gene trees (see more on the data in Inputs for SNaQ):","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"raxmltrees = joinpath(dirname(pathof(SNaQ)), \"..\",\"examples\",\"raxmltrees.tre\");\nraxmlCF = readtrees2CF(raxmltrees);","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Typing varinfo() will provide a list of objects and packages in memory, including raxmlCF that we just created. If we want to know the type of a particular object, we do:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"typeof(raxmlCF)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"which shows us that raxmlCF is of type DataCF. If we want to know about the attributes the object has, we can type ? in Julia, followed by DataCF for a description. We can also ask for a list of all its attributes with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"fieldnames(typeof(raxmlCF))","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"For example, we see that one attribute is numQuartets: its the number of 4-taxon subsets in the data. To see what this number is:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"raxmlCF.numQuartets","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"We also noticed an attribute quartet. It is a vector of Quartet objects inside raxmlCF, so","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"raxmlCF.quartet[2].taxon","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"will provide the list of taxon names for the second 4-taxon subset in the data. To see the observed CF, we can type","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"raxmlCF.quartet[2].obsCF","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"We can verify the type with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"typeof(raxmlCF.quartet[2])","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"info: Important Note:\nThis documentation pertains to SNaQ v1.1 and may differ from the specific implementation originally described in Solís-Lemus & Ané (2016). See documentation SNaQ v1.0  for the original implementation.","category":"page"},{"location":"man/bootstrap/#Bootstrap","page":"Bootstrap","title":"Bootstrap","text":"","category":"section"},{"location":"man/bootstrap/#Running-a-bootstrap-analysis","page":"Bootstrap","title":"Running a bootstrap analysis","text":"","category":"section"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"There are two ways to do a bootstrap analysis.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"First, we can use a table of quartet CFs estimated with credibility intervals, such as if we used BUCKy. The TICR pipeline outputs a CF table with extra columns for credibility intervals. We could then read that table and get bootstrap networks like this, and tweak options as needed:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"using DataFrames, CSV\ndf = CSV.read(\"tableCF_withCI.csv\", DataFrame)\nbootnet = bootsnaq(startnetwork, df, hmax=1, filename=\"bootstrap\")","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Alternatively, we can use bootstrap gene trees: one file of bootstrap trees per gene. Here, the input is a text file that lists all the bootstrap files (one per gene). We demonstrate this second option here.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"The names of all our bootstrap files are listed in \"BSlistfiles\". (ASTRAL can use the same file to do its own bootstrap, see PhyloUtilities).","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"The PhyloNetworks function PhyloNetworks.readmultinewick_files can read this list of file names, then read each bootstrap file to get the bootstrap sample for each gene. We can use them to sample input gene trees at random, one per gene, and estimate a network from them. We ask the bootsnaq function to repeat this resampling of bootstrap gene trees several times.","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"bootTrees = readmultinewick_files(\"BSlistfiles\");\nbootnet = bootsnaq(net0, bootTrees, hmax=1, nrep=10, runs=3,\n                   filename=\"bootsnaq\", seed=4321)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"The bootstrap networks are saved in the boostrap.out file, so they can be read in a new session with bootnet = readmultinewick(\"bootsnaq.out\"). To save the bootstrap networks to a different file (perhaps after having re-rooted them with an outgroup), we could do this: writeMultiTopology(bootnet, \"bootstrapNets.tre\").","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"The example above creates 10 bootstrap replicates, which is definitely too few, to make the example run faster. We might also increase the number of optimization runs (runs) done for each bootstrap replicate. The following bootstrap was run with the default 10 runs per replicate, and 100 bootstrap replicates, and the 100 bootstrap networks come with the package:","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"bootnet = readmultinewick(joinpath(dirname(pathof(SNaQ)), \"..\",\"examples\",\"bootsnaq.out\"));\nlength(bootnet)","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"If we used a specified list of quartets on the original data, we should use that same list for the bootstrap analysis through the option quartetfile.","category":"page"},{"location":"man/bootstrap/#Support-for-tree-and-hybrid-edges","page":"Bootstrap","title":"Support for tree and hybrid edges","text":"","category":"section"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Now that we have 100 bootstrap networks, we need to summarize what they have in common (highly supported features) and what they don't (areas of uncertainty).","category":"page"},{"location":"man/bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"We can use PhyloNetworks functions to quantify Network support.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Important Note:\nThis documentation pertains to SNaQ v1.1 and may differ from the specific implementation originally described in Solís-Lemus & Ané (2016). See documentation SNaQ v1.0  for the original implementation.","category":"page"},{"location":"#SNaQ","page":"Home","title":"SNaQ","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SNaQ is a Julia package as a part of the JuliaPhylo software ecosystem.  The package implements the SNaQ method by Solís-Lemus & Ané (2016) to estimate a phylogenetic network from quartet concordance factors. See the PhyloNetworks package, which SNaQ depends on, for background on phylogenetic networks and for how to get help. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Join the PhyloNetworks google group for updates here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More information about the pre-processing steps to get the input data for SNaQ can be found in PhyloUtilities and the snaq tutorial.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the SNaQ network inference method itself:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Claudia Solís-Lemus and Cécile Ané (2016). Inferring Phylogenetic Networks with Maximum Pseudolikelihood under Incomplete Lineage Sorting. PLoS Genetics 12(3):e1005896. doi:10.1371/journal.pgen.1005896","category":"page"},{"location":"","page":"Home","title":"Home","text":"For PhyloNetworks package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Claudia Solís-Lemus, Paul Bastide and Cécile Ané (2017).  PhyloNetworks: a package for phylogenetic networks. Molecular Biology and Evolution 34(12):3292–3298. doi:10.1093/molbev/msx235","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the references in bibtex format.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages =  [\n\"man/installation.md\",\n\"man/snaq_est.md\",\n\"man/fixednetworkoptim.md\",\n\"man/expectedCFs.md\",\n\"man/bootstrap.md\",\n\"man/parallelcomputation.md\",\n\"man/multiplealleles.md\",\n\"man/error_reporting.md\"\n]\nDepth = 3","category":"page"},{"location":"#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For help on individual functions, see the library:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"lib\", file), readdir(\"lib\"))\nDepth = 1","category":"page"}]
}
