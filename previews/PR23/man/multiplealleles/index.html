<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multiple alleles · SNaQ.jl</title><meta name="title" content="Multiple alleles · SNaQ.jl"/><meta property="og:title" content="Multiple alleles · SNaQ.jl"/><meta property="twitter:title" content="Multiple alleles · SNaQ.jl"/><meta name="description" content="Documentation for SNaQ.jl."/><meta property="og:description" content="Documentation for SNaQ.jl."/><meta property="twitter:description" content="Documentation for SNaQ.jl."/><meta property="og:url" content="https://JuliaPhylo.github.io/SNaQ.jl/man/multiplealleles/"/><meta property="twitter:url" content="https://JuliaPhylo.github.io/SNaQ.jl/man/multiplealleles/"/><link rel="canonical" href="https://JuliaPhylo.github.io/SNaQ.jl/man/multiplealleles/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SNaQ.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SNaQ.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../snaq_est/">Network estimation</a></li><li><a class="tocitem" href="../fixednetworkoptim/">Candidate networks</a></li><li><a class="tocitem" href="../expectedCFs/">Extract expected CFs</a></li><li><a class="tocitem" href="../bootstrap/">Bootstrap</a></li><li><a class="tocitem" href="../parallelcomputation/">Improving runtimes</a></li><li class="is-active"><a class="tocitem" href>Multiple alleles</a><ul class="internal"><li><a class="tocitem" href="#Between-species-4-taxon-sets"><span>Between-species 4-taxon sets</span></a></li><li><a class="tocitem" href="#Within-species-4-taxon-sets"><span>Within-species 4-taxon sets</span></a></li></ul></li><li><a class="tocitem" href="../error_reporting/">Error reporting</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/public/">Public</a></li><li><a class="tocitem" href="../../lib/internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Multiple alleles</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multiple alleles</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/SNaQ.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/dev/docs/temp_src_for_build/man/multiplealleles.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><div class="admonition is-info" id="Important-Note:-6724263f5023a524"><header class="admonition-header">Important Note:<a class="admonition-anchor" href="#Important-Note:-6724263f5023a524" title="Permalink"></a></header><div class="admonition-body"><p>This documentation pertains to SNaQ v1.1 and may differ from the specific implementation originally described in <a href="https://doi.org/10.1371/journal.pgen.1005896">Solís-Lemus &amp; Ané (2016)</a>. See documentation SNaQ v1.0  for the original implementation.</p></div></div><h1 id="Multiple-alleles-per-species"><a class="docs-heading-anchor" href="#Multiple-alleles-per-species">Multiple alleles per species</a><a id="Multiple-alleles-per-species-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-alleles-per-species" title="Permalink"></a></h1><h2 id="Between-species-4-taxon-sets"><a class="docs-heading-anchor" href="#Between-species-4-taxon-sets">Between-species 4-taxon sets</a><a id="Between-species-4-taxon-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Between-species-4-taxon-sets" title="Permalink"></a></h2><p>The default setting for SNaQ considers that each allele in a gene tree corresponds to a taxon (a tip) in the network. If instead each allele/individual can be mapped confidently to a species, and if only the species-level network needs to be estimated, then the following functions can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using CSV, DataFrames</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mappingfile = joinpath(dirname(pathof(SNaQ)), &quot;..&quot;,&quot;examples&quot;,
           &quot;mappingIndividuals.csv&quot;);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tm = CSV.read(mappingfile, DataFrame) # taxon map as a data frame</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">3×2 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> species  individual </span>
<span class="sgr1">     </span>│<span class="sgr90"> String3  String3    </span>
─────┼─────────────────────
   1 │ S1       S1A
   2 │ S1       S1B
   3 │ S1       S1C</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; taxonmap = Dict(r[:individual] =&gt; r[:species] for r in eachrow(tm)) # as dictionary</code><code class="nohighlight hljs ansi" style="display:block;">Dict{InlineStrings.String3, InlineStrings.String3} with 3 entries:
  &quot;S1A&quot; =&gt; &quot;S1&quot;
  &quot;S1B&quot; =&gt; &quot;S1&quot;
  &quot;S1C&quot; =&gt; &quot;S1&quot;</code></pre><p>The <a href="https://github.com/juliaphylo/SNaQ/blob/main/examples/mappingIndividuals.csv">mapping file</a> can be a text (or <code>csv</code>) file with two columns (at least): one for the individuals, named <code>allele</code> or <code>individual</code>, and one column containing the species names, named <code>species</code>. Each row should map an allele name to a species name. Next, read in the <a href="https://github.com/juliaphylo/SNaQ/blob/main/examples/genetrees_alleletips.tre">gene trees</a> and calculate the quartet CFs at the species level:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; genetreefile = joinpath(dirname(pathof(SNaQ)), &quot;..&quot;,&quot;examples&quot;,
           &quot;genetrees_alleletips.tre&quot;);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; genetrees = readmultinewick(genetreefile);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sort(tiplabels(genetrees[1])) # multiple tips in species S1</code><code class="nohighlight hljs ansi" style="display:block;">7-element Vector{String}:
 &quot;S1A&quot;
 &quot;S1B&quot;
 &quot;S1C&quot;
 &quot;S2&quot;
 &quot;S3&quot;
 &quot;S4&quot;
 &quot;S5&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_sp = tablequartetCF(countquartetsintrees(genetrees, taxonmap;
           showprogressbar=false)...);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(df_sp)  # columns names</code><code class="nohighlight hljs ansi" style="display:block;">(:qind, :t1, :t2, :t3, :t4, :CF12_34, :CF13_24, :CF14_23, :ngenes)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_sp[:qind] # quartet index</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Int64}:
 1
 2
 3
 4
 5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_sp[:t1]   # name of first taxon in each quartet</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{AbstractString}:
 &quot;S1&quot;
 &quot;S1&quot;
 &quot;S1&quot;
 &quot;S1&quot;
 &quot;S2&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_sp[:CF12_34] # concordance factor for split taxa 12 vs 34</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 0.08333333333333329
 0.08333333333333329
 0.875
 1.0
 0.875</code></pre><p>Now <code>df_sp</code> is a table (technically, a named tuple) containing the quartet concordance factors at the species level only, that is, considering sets made of 4 distinct species, even if the gene trees may have multiple alleles from the same species. For 4 distinct species <code>A,B,C,D</code>, all alleles from each species (<code>A</code> etc.) will be used to calculate the quartet CF. If a given gene tree has <code>n_a</code> alleles from <code>a</code>, <code>n_b</code> alleles from <code>b</code> etc., then each set of 4 alleles is given a weight of <code>1/(n_a n_b n_c n_d)</code> to calculated of the CF for <code>A,B,C,D</code> (such that the total weight from this particular gene trees is 1). It is safe to save this data frame, then use it for <code>snaq!</code> like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; CSV.write(&quot;tableCF_species.csv&quot;, df_sp);   # to save the table to a file</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d_sp = readtableCF(&quot;tableCF_species.csv&quot;); # &quot;DataCF&quot; object for use in snaq!</code><code class="nohighlight hljs ansi" style="display:block;">16.0 gene trees per 4-taxon set</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; summarizedataCF(d_sp)</code><code class="nohighlight hljs ansi" style="display:block;">data consists of 5 4-taxon subsets
Taxa: [&quot;S1&quot;, &quot;S2&quot;, &quot;S3&quot;, &quot;S4&quot;, &quot;S5&quot;]
Number of Taxa: 5
Maximum number of 4-taxon subsets: 5. Thus, 100.0 percent of 4-taxon subsets sampled</code></pre><h2 id="Within-species-4-taxon-sets"><a class="docs-heading-anchor" href="#Within-species-4-taxon-sets">Within-species 4-taxon sets</a><a id="Within-species-4-taxon-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Within-species-4-taxon-sets" title="Permalink"></a></h2><p>Four-taxon sets involving 2 individuals per species can provide more information about the underlying network, including external branch length in coalescent units. However, <a href="../../lib/public/#SNaQ.snaq!-Tuple{HybridNetwork, DataCF}"><code>snaq!</code></a> runs more slowly when using this extra information.</p><p>To get quartet CFs from sets of 4 individuals in which 2 individuals are from the same species, the following functions should be used, where the mapping file can be a text (or <code>csv</code>) file with two columns named <code>allele</code> (or <code>individual</code>) and <code>species</code>, mapping each allele name to a species name.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; q,t = countquartetsintrees(genetrees);</code><code class="nohighlight hljs ansi" style="display:block;">Reading in trees, looking at 35 quartets in each...
0+----------------+100%
  ****************</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_ind = DataFrame(tablequartetCF(q,t)); # no mapping: CFs across individuals</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; first(df_ind, 5) # to see the first 5 rows</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">5×9 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> qind   t1      t2      t3      t4      CF12_34  CF13_24  CF14_23  ngene</span> ⋯
<span class="sgr1">     </span>│<span class="sgr90"> Int64  String  String  String  String  Float64  Float64  Float64  Float</span> ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │     1  S1A     S1B     S1C     S2       0.375    0.25     0.375      16 ⋯
   2 │     2  S1A     S1B     S1C     S3       0.375    0.25     0.375      16
   3 │     3  S1A     S1B     S2      S3       0.8125   0.0625   0.125      16
   4 │     4  S1A     S1C     S2      S3       0.75     0.125    0.125      16
   5 │     5  S1B     S1C     S2      S3       0.8125   0.125    0.0625     16 ⋯
<span class="sgr36">                                                                1 column omitted</span></code></pre><p>Now <code>df_ind</code> is the table of concordance factors at the level of individuals. In other words, it lists CFs using one row for each set of 4 alleles/individuals.</p><p><strong>Warning</strong>: This procedure requires that all alleles from the same individual are given the same name (the individual&#39;s &#39;name&#39;) <em>across all genes</em> for which that individual was sequenced.</p><p>Next, we use <a href="../../lib/public/#SNaQ.mapallelesCFtable-Tuple{AbstractString, AbstractString}"><code>mapallelesCFtable</code></a> to get these data as quartet concordance factors at the species level in <code>df_sp</code>: with the allele names replaced by the appropriate species names.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; CSV.write(&quot;tableCF_individuals.csv&quot;, df_ind);  # to save to a file</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_sp = mapallelesCFtable(mappingfile, &quot;tableCF_individuals.csv&quot;;
           columns=2:5); # taxon names are in columns 2 through 5, not default 1-4</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr33"><span class="sgr1">┌ Warning: </span></span>not all alleles were mapped
<span class="sgr33"><span class="sgr1">│ </span></span>alleles not mapped to a species name: S2 S3 S4 S5
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ SNaQ ~/work/SNaQ.jl/SNaQ.jl/src/multipleAlleles.jl:236</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nrow(df_sp)       # 35 quartets of individuals</code><code class="nohighlight hljs ansi" style="display:block;">35</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; first(df_sp, 6)   # first 6 rows of data frame</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">6×9 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> qind   t1      t2      t3      t4      CF12_34  CF13_24  CF14_23  ngene</span> ⋯
<span class="sgr1">     </span>│<span class="sgr90"> Int64  String  String  String  String  Float64  Float64  Float64  Float</span> ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │     1  S1      S1      S1      S2       0.375    0.25     0.375      16 ⋯
   2 │     2  S1      S1      S1      S3       0.375    0.25     0.375      16
   3 │     3  S1      S1      S2      S3       0.8125   0.0625   0.125      16
   4 │     4  S1      S1      S2      S3       0.75     0.125    0.125      16
   5 │     5  S1      S1      S2      S3       0.8125   0.125    0.0625     16 ⋯
   6 │     6  S1      S1      S1      S4       0.375    0.25     0.375      16
<span class="sgr36">                                                                1 column omitted</span></code></pre><p>The warning above, after creating <code>df_sp</code>, is because our mapping file does not list species S2 through S5. We did not need to list them because we have a single individual in each of these species. So we can safely ignore the warning. We will just need to make sure that our starting tree, when we run SNaQ, has the same (unmapped) names, here S2-S5.</p><p>The command below modifies <code>df_sp</code> to delete rows that are uninformative about between-species relationships, such as rows containing 3 or 4 individuals from the same species (e.g. rows 1, 2 and 6: they contain S1 three times); and creates <code>d_sp</code>, an object of type <a href="../../lib/public/#SNaQ.DataCF"><code>DataCF</code></a> at the species level, that we can use later as input for networks estimation with <a href="../../lib/public/#SNaQ.snaq!-Tuple{HybridNetwork, DataCF}"><code>snaq!</code></a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; d_sp = readtableCF!(df_sp, mergerows=true); # DataCF object</code><code class="nohighlight hljs ansi" style="display:block;">found 4 4-taxon sets uninformative about between-species relationships, out of 35.
These 4-taxon sets will be deleted from the data frame.
31 informative 4-taxon sets will be used.
11 unique 4-taxon sets were found.
CF values of repeated 4-taxon sets will be averaged (ngenes too).
16.0 gene trees per 4-taxon set</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nrow(df_sp) # 31 quartets of individuals informative between species</code><code class="nohighlight hljs ansi" style="display:block;">31</code></pre><div class="admonition is-info" id="Note-7bed2dd0f8ab3c37"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-7bed2dd0f8ab3c37" title="Permalink"></a></header><div class="admonition-body"><p>For a four-taxon set <code>A,B,C,D</code>, all the individuals from <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code> are considered, say <code>(a1,b1,c1,d1)</code>, <code>(a2,b1,c1,d1)</code>, <code>(a1,b2,c1,d1)</code>, <code>(a2,b2,c1,d1)</code> and so on. The CFs of these 4-taxon sets are averaged together to obtain the CFs at the species level. This procedures gives more weight to genes that have many alleles (because they contribute to more sets of 4 individuals) and less weight to genes that have few alleles.</p></div></div><p>Before we run SNaQ, it is safe to save the concordance factor of <em>species</em> quartets, which can be calculated by averaging the CFs of quartets of individuals from the associated species:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_sp_ave = DataFrame(tablequartetCF(d_sp))  # CFs averaged across individuals</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">11×8 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> t1      t2      t3      t4      CF12_34    CF13_24   CF14_23   ngenes   </span>
<span class="sgr1">     </span>│<span class="sgr90"> String  String  String  String  Float64    Float64   Float64   Float64? </span>
─────┼─────────────────────────────────────────────────────────────────────────
   1 │ S1      S1__2   S2      S3      0.791667   0.104167  0.104167      16.0
   2 │ S1      S1__2   S2      S4      0.875      0.0625    0.0625        16.0
   3 │ S1      S1__2   S3      S4      0.791667   0.104167  0.104167      16.0
   4 │ S1      S2      S3      S4      0.0833333  0.854167  0.0625        16.0
   5 │ S1      S1__2   S2      S5      0.875      0.0625    0.0625        16.0
   6 │ S1      S1__2   S3      S5      0.791667   0.104167  0.104167      16.0
   7 │ S1      S2      S3      S5      0.0833333  0.854167  0.0625        16.0
   8 │ S1      S1__2   S4      S5      1.0        0.0       0.0           16.0
   9 │ S1      S2      S4      S5      0.875      0.0625    0.0625        16.0
  10 │ S1      S3      S4      S5      1.0        0.0       0.0           16.0
  11 │ S2      S3      S4      S5      0.875      0.0625    0.0625        16.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; CSV.write(&quot;CFtable_species.csv&quot;, df_sp_ave); # save to file</code></pre><p>Some quartets have the same species repeated twice, representing cases when 2 of the 4 individuals came from the same species. These quartets, with repeated species, are informative about the population size of extant populations, i.e. about the lengths of external branches in coalescent units.</p><p>The main difference between this section compared to the previous section on <a href="#Between-species-4-taxon-sets">Between-species 4-taxon sets</a> is that quartets with 2 individuals from the same species are included here, such as <code>a1,a2,b1,c1</code>. Also, the weighting of quartets is different. Here, genes with more alleles are given more weight.</p><p>now we can run <code>snaq!</code>:</p><pre><code class="language-julia hljs">net = snaq!(T_sp, d_sp);</code></pre><p>where <code>T_sp</code> should be a starting topology with one tip per species, labelled with the same species names as the names used in the mapping file.</p><p>If <code>snaq!</code> takes too long that way, we can try a less ambitious estimation that does not estimate the external branch lengths, that is, <em>without</em> using quartets that have 2 individuals from the same species. To do so, we can use the quartet concordance factors at the species level, but filter out the quartets with one (or more) species repeated, such as these below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; first(df_sp_ave, 3) # some quartets have the same species twice</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">3×8 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> t1      t2      t3      t4      CF12_34   CF13_24   CF14_23   ngenes   </span>
<span class="sgr1">     </span>│<span class="sgr90"> String  String  String  String  Float64   Float64   Float64   Float64? </span>
─────┼────────────────────────────────────────────────────────────────────────
   1 │ S1      S1__2   S2      S3      0.791667  0.104167  0.104167      16.0
   2 │ S1      S1__2   S2      S4      0.875     0.0625    0.0625        16.0
   3 │ S1      S1__2   S3      S4      0.791667  0.104167  0.104167      16.0</code></pre><p>Filtering them out can be done as in the first section (<a href="#Between-species-4-taxon-sets">Between-species 4-taxon sets</a>) to give equal weight to all genes, or as shown below to give more weight to genes that have more alleles. We first define a helper function to identify which rows we want to get rid of.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; first(df_sp_ave, 3) # some quartets have the same species twice</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">3×8 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> t1      t2      t3      t4      CF12_34   CF13_24   CF14_23   ngenes   </span>
<span class="sgr1">     </span>│<span class="sgr90"> String  String  String  String  Float64   Float64   Float64   Float64? </span>
─────┼────────────────────────────────────────────────────────────────────────
   1 │ S1      S1__2   S2      S3      0.791667  0.104167  0.104167      16.0
   2 │ S1      S1__2   S2      S4      0.875     0.0625    0.0625        16.0
   3 │ S1      S1__2   S3      S4      0.791667  0.104167  0.104167      16.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; &quot;&quot;&quot;
           hasrep
       
       Return true if a row (4-taxon set) has a &quot;repeated&quot; species, that is, a species
       whose name ends with &quot;__2&quot;. Otherwise, return false.
       
       Warning: this function assumes that taxon names are in columns
       &quot;t1&quot;, &quot;t2&quot;, &quot;t3&quot;, &quot;t4&quot;. For data frames with different column names,
       e.g. &quot;taxon1&quot;, &quot;taxon2&quot; etc., simply edit the code below by replacing
       `:t1` by `:taxon1` (or the appropriate column name in your data).
       &quot;&quot;&quot;
       function hasrep(row)
           occursin(r&quot;__2$&quot;, row[:t1]) || occursin(r&quot;__2$&quot;, row[:t2]) ||
           occursin(r&quot;__2$&quot;, row[:t3]) || occursin(r&quot;__2$&quot;, row[:t4])
       end; # this function is used on the next line</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_sp_reduced = filter(!hasrep, df_sp_ave) # removes rows with repeated species</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">5×8 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> t1      t2      t3      t4      CF12_34    CF13_24   CF14_23  ngenes   </span>
<span class="sgr1">     </span>│<span class="sgr90"> String  String  String  String  Float64    Float64   Float64  Float64? </span>
─────┼────────────────────────────────────────────────────────────────────────
   1 │ S1      S2      S3      S4      0.0833333  0.854167   0.0625      16.0
   2 │ S1      S2      S3      S5      0.0833333  0.854167   0.0625      16.0
   3 │ S1      S2      S4      S5      0.875      0.0625     0.0625      16.0
   4 │ S1      S3      S4      S5      1.0        0.0        0.0         16.0
   5 │ S2      S3      S4      S5      0.875      0.0625     0.0625      16.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; CSV.write(&quot;CFtable_species_norep.csv&quot;, df_sp_reduced); # to save to file</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d_sp_reduced = readtableCF(df_sp_reduced) # DataCF object, for input to snaq!</code><code class="nohighlight hljs ansi" style="display:block;">16.0 gene trees per 4-taxon set
Object DataCF
number of quartets: 5</code></pre><p>and now we can run <code>snaq!</code> on the reduced set of quartets without repeats, which should be faster:</p><pre><code class="language-julia hljs">net = snaq!(T_sp, d_sp_reduced);</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../parallelcomputation/">« Improving runtimes</a><a class="docs-footer-nextpage" href="../error_reporting/">Error reporting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 12 November 2025 20:33">Wednesday 12 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
