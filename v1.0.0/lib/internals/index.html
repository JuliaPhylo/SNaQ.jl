<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · SNaQ.jl</title><meta name="title" content="Internals · SNaQ.jl"/><meta property="og:title" content="Internals · SNaQ.jl"/><meta property="twitter:title" content="Internals · SNaQ.jl"/><meta name="description" content="Documentation for SNaQ.jl."/><meta property="og:description" content="Documentation for SNaQ.jl."/><meta property="twitter:description" content="Documentation for SNaQ.jl."/><meta property="og:url" content="https://JuliaPhylo.github.io/SNaQ.jl/lib/internals/"/><meta property="twitter:url" content="https://JuliaPhylo.github.io/SNaQ.jl/lib/internals/"/><link rel="canonical" href="https://JuliaPhylo.github.io/SNaQ.jl/lib/internals/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SNaQ.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SNaQ.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/installation/">Installation</a></li><li><a class="tocitem" href="../../man/snaq_est/">Network estimation</a></li><li><a class="tocitem" href="../../man/fixednetworkoptim/">Candidate networks</a></li><li><a class="tocitem" href="../../man/expectedCFs/">Extract expected CFs</a></li><li><a class="tocitem" href="../../man/bootstrap/">Bootstrap</a></li><li><a class="tocitem" href="../../man/parallelcomputation/">Parallel computation</a></li><li><a class="tocitem" href="../../man/multiplealleles/">Multiple alleles</a></li><li><a class="tocitem" href="../../man/error_reporting/">Error reporting</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../public/">Public</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Functions-and-Types"><span>Functions &amp; Types</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/SNaQ.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/dev/docs/src/lib/internals.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-Documentation"><a class="docs-heading-anchor" href="#Internal-Documentation">Internal Documentation</a><a id="Internal-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Documentation" title="Permalink"></a></h1><p>Documentation for <code>SNaQ</code>&#39;s internal functions. These functions are not exported and their access (API) should not be considered stable. But they can still be used, like this for example: <code>SNaQ.foo()</code> for a function named <code>foo()</code>.</p><h2 id="Functions-and-Types"><a class="docs-heading-anchor" href="#Functions-and-Types">Functions &amp; Types</a><a id="Functions-and-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.QuartetNetwork" href="#SNaQ.QuartetNetwork"><code>SNaQ.QuartetNetwork</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuartetNetwork(net::HybridNetwork)</code></pre><p>Subtype of <code>Network</code> abstract type. A <code>QuartetNetwork</code> object is an internal type used to calculate the expected CFs of quartets on a given network. Attributes of the <code>QuartetNetwork</code> objects need not be updated at a given time (see below).</p><p>The procedure to calculate expected CFs for a given network is as follows:</p><ol><li>A <code>QuartetNetwork</code> object is created for each <code>Quartet</code> using <code>extractQuartet!(net,d)</code> for <code>net::HybridNetwork</code> and <code>d::DataCF</code></li><li>The vector <code>d.quartet</code> has all the <code>Quartet</code> objects, each with a <code>QuartetNetwork</code> object (<code>q.qnet</code>). Attibutes in <code>QuartetNetwork</code> are not updated at this point</li><li>Attributes in <code>QuartetNetwork</code> are partially updated when calculating the expected CF (<code>calculateExpCFAll!</code>). To calculate the expected CF for this quartet, we need to update the attributes: <code>which</code>, <code>typeHyb</code>, <code>t1</code>, <code>split</code>, <code>formula</code>, <code>expCF</code>. To do this, we need to modify the <code>QuartetNetwork</code> object (i.e. merge edges,...). But we do not want to modify it directly because it is connected to the original <code>net</code> via a map of the edges and nodes, so we use a deep copy: <code>qnet=deepcopy(q.qnet)</code> and then <code>calculateExpCFAll!(qnet)</code>. Attributes that are updated on the original <code>QuartetNetwork</code> object <code>q.qnet</code> are:<ul><li><code>q.qnet.hasEdge</code>: array of booleans of length equal to <code>net.edge</code> that shows which identifiable edges and gammas of <code>net</code> (<code>ht(net)</code>) are in <code>qnet</code> (and still identifiable). Note that the first elements of the vector correspond to the gammas.</li><li><code>q.qnet.index</code>: length should match the number of trues in <code>qnet.hasEdge</code>. It has the indexes in <code>qnet.edge</code> from the edges in <code>qnet.hasEdge</code>. Note that the first elements of the vector correspond to the gammas.</li><li><code>q.qnet.edge</code>: list of edges in <code>QuartetNetwork</code>. Note that external edges in <code>net</code> are collapsed when they appear in <code>QuartetNetwork</code>, so only internal edges map directly to edges in <code>net</code></li><li><code>q.qnet.expCF</code>: expected CF for this <code>Quartet</code></li></ul></li></ol><p>Why not modify the original <code>QuartetNetwork</code>? We wanted to keep the original <code>QuartetNetwork</code> stored in <code>DataCF</code> with all the identifiable edges, to be able to determine if this object had been changed or not after a certain optimization.</p><p>The process is:</p><ol><li>Deep copy of full network to create <code>q.qnet</code> for <code>Quartet q</code>. This <code>QuartetNetwork</code> object has only 4 leaves now, but does not have merged edges (the identifiable ones) so that we can correspond to the edges in net. This <code>QuartetNetwork</code> does not have other attributes updated.</li><li>For the current set of branch lengths and gammas, we can update the attributes in <code>q.qnet</code> to compute the expected CF. The functions that do this will &quot;destroy&quot; the <code>QuartetNetwork</code> object by merging edges, removing nodes, etc... So, we do this process in <code>qnet=deepcopy(q.qnet)</code>, and at the end, only update <code>q.qnet.expCF</code>.</li><li>After we optimize branch lengths in the full network, we want to update the branch lengths in <code>q.qnet</code>. The edges need to be there (which is why we do not want to modify this <code>QuartetNetwork</code> object by merging edges), and we do not do a deep-copy of the full network again. We only change the values of branch lengths and gammas in <code>q.qnet</code>, and we can re-calculate the expCF by creating a deep copy <code>qnet=deepcopy(q.qnet)</code> and run the other functions (which merge edges, etc) to get the <code>expCF</code>.</li></ol><p>Future work: there are definitely more efficient ways to do this (without the deep copies). In addition, currently edges that are no longer identifiable in <code>QuartetNetwork</code> do not appear in <code>hasEdge</code> nor <code>index</code>. Need to study this.</p><pre><code class="language-julia-repl hljs">julia&gt; net0 = readnewick(&quot;(s17:13.76,(((s3:10.98,(s4:8.99,s5:8.99)I1:1.99)I2:0.47,(((s6:2.31,s7:2.31)I3:4.02,(s8:4.97,#H24:0.0::0.279)I4:1.36)I5:3.64,((s9:8.29,((s10:2.37,s11:2.37)I6:3.02,(s12:2.67,s13:2.67)I7:2.72)I8:2.89)I9:0.21,((s14:2.83,(s15:1.06,s16:1.06)I10:1.78)I11:2.14)#H24:3.52::0.72)I12:1.47)I13:1.48)I14:1.26,(((s18:5.46,s19:5.46)I15:0.59,(s20:4.72,(s21:2.40,s22:2.40)I16:2.32)I17:1.32)I18:2.68,(s23:8.56,(s1:4.64,s2:4.64)I19:3.92)I20:0.16)I21:3.98)I22:1.05);&quot;);

julia&gt; net = readnewicklevel1(writenewick(net0)) ## need level1 attributes for functions below
HybridNetwork, Semidirected Network
46 edges
46 nodes: 23 tips, 1 hybrid nodes, 22 internal tree nodes.
tip labels: s17, s3, s4, s5, ...
(s4:8.99,s5:8.99,(s3:10.0,((((s6:2.31,s7:2.31)I3:4.02,(s8:4.97,#H24:0.0::0.279)I4:1.36)I5:3.64,((s9:8.29,((s10:2.37,s11:2.37)I6:3.02,(s12:2.67,s13:2.67)I7:2.72)I8:2.89)I9:0.21,((s14:2.83,(s15:1.06,s16:1.06)I10:1.78)I11:2.14)#H24:3.52::0.721)I12:1.47)I13:1.48,((((s18:5.46,s19:5.46)I15:0.59,(s20:4.72,(s21:2.4,s22:2.4)I16:2.32)I17:1.32)I18:2.68,(s23:8.56,(s1:4.64,s2:4.64)I19:3.92)I20:0.16)I21:3.98,s17:10.0)I22:1.26)I14:0.47)I2:1.99)I1;

julia&gt; q1 = Quartet(1,[&quot;s1&quot;, &quot;s16&quot;, &quot;s18&quot;, &quot;s23&quot;],[0.296,0.306,0.398])
number: 1
taxon names: [&quot;s1&quot;, &quot;s16&quot;, &quot;s18&quot;, &quot;s23&quot;]
observed CF: [0.296, 0.306, 0.398]
pseudo-deviance under last used network: 0.0 (meaningless before estimation)
expected CF under last used network: Float64[] (meaningless before estimation)

julia&gt; qnet = SNaQ.extractQuartet!(net,q1)
taxa: [&quot;s1&quot;, &quot;s16&quot;, &quot;s18&quot;, &quot;s23&quot;]
number of hybrid nodes: 1

julia&gt; sum([SNaQ.istIdentifiable(e) for e in net.edge]) ## 23 identifiable edges in net
23

julia&gt; idedges = [ee.number for ee in net.edge[[SNaQ.istIdentifiable(e) for e in net.edge]]];

julia&gt; print(idedges)
[5, 6, 9, 11, 12, 13, 17, 20, 21, 22, 26, 27, 28, 29, 30, 31, 34, 38, 39, 40, 44, 45, 46]

julia&gt; length(qnet.hasEdge) ## 24 = 1 gamma + 23 identifiable edges
24

julia&gt; sum(qnet.hasEdge) ## 8 = 1 gamma + 7 identifiable edges in qnet
8

julia&gt; print(idedges[qnet.hasEdge[2:end]]) ## 7 id. edges: [12, 13, 29, 30, 31, 45, 46]
[12, 13, 29, 30, 31, 45, 46]

julia&gt; qnet.edge[qnet.index[1]].number ## 11 = minor hybrid edge
11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/types.jl#L74-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.printedges-Tuple{IO, SNaQ.QuartetNetwork}" href="#PhyloNetworks.printedges-Tuple{IO, SNaQ.QuartetNetwork}"><code>PhyloNetworks.printedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">printedges([io::IO,] quartetnet)</code></pre><p>Print information on the edges of a <code>QuartetNetwork</code> object <code>quartetnet</code>:</p><ul><li>edge number</li><li>numbers of nodes attached to it</li><li>edge length</li><li>whether it&#39;s a hybrid edge</li><li>whether it&#39;s a major edge</li><li>its γ inheritance value</li><li>if it could contain the root (this field is not always updated, though)</li><li>in which cycle it is contained (-1 if no cycle)</li><li>if its length is identifiable from quartet concordance factors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/auxiliary.jl#L82-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloNetworks.tablequartetCF-Tuple{Vector{Quartet}}" href="#PhyloNetworks.tablequartetCF-Tuple{Vector{Quartet}}"><code>PhyloNetworks.tablequartetCF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tablequartetCF(vector of Quartet objects)
tablequartetCF(DataCF)
tablequartetCF(gene trees)
tablequartetCF(gene tree file)</code></pre><p>Build a NamedTuple containing observed quartet concordance factors, with the fields named:</p><ul><li><code>t1</code>, <code>t2</code>, <code>t3</code>, <code>t4</code> for the four taxon names in each quartet</li><li><code>CF12_34</code>, <code>CF13_24</code>, <code>CF14_23</code> for the 3 quartets of a given four-taxon set</li><li><code>ngenes</code> if this information is available for some quartets</li></ul><p>Some downstream functions may require the observed quartet concordance factors to be in a DataFrame, this can be easily converted by wrapping the output NamedTuple in the <code>DataFrame()</code> function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/readquartetdata.jl#L16-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.afterOptBL!-Tuple{HybridNetwork, DataCF, Bool, Bool, Bool, Integer, Vector{Int64}}" href="#SNaQ.afterOptBL!-Tuple{HybridNetwork, DataCF, Bool, Bool, Bool, Integer, Vector{Int64}}"><code>SNaQ.afterOptBL!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">afterOptBL!</code></pre><p>Check if there are <code>h==0,1;t==0,hz==0,1</code> cases in a network after calling <code>optBL!</code>.</p><p>Output: <code>(successchange,flagh,flagt,flaghz)</code> where <code>successchange</code> is <code>false</code> if could not add new hybrid; <code>true</code> otherwise. Flags <code>flag*</code> is <code>false</code> if there is problem with gamma, t=0 or gammaz.</p><p>Arguments:</p><ul><li><code>closeN: move origin/target if</code>true<code>; if</code>false<code>add/delete</code>N<code>times before giving up (we have only tested</code>closeN=true`)</li><li><code>origin=true</code> will move origin, false will move target. We added this to avoid going back and forth between the same networks</li><li><code>movesgamma</code>: vector of integers. Counts the number of times each move is proposed to fix a gamma zero problem. Proposal types and order: <code>(add, mvorigin, mvtarget, chdir, delete, nni)</code>.</li></ul><p>Procedure:</p><ul><li><p>First we split the <code>ht</code> vector in <code>nh,nt,nhz</code> (gammas, lengths, gammaz)</p></li><li><p>If we find a <code>h==0,1</code>, we loop through <code>nh</code> to find a hybrid edge with h==0 or 1 and want to try to fix this by doing:</p><ul><li><code>gammaZero!(currT,d,edge,closeN,origin,N,movesgamma)</code> which returns true if there was a successful change, and we stop the loop</li></ul></li><li><p>If we find a <code>t==0</code>, we loop through all <code>nt</code> to find such edge, and do NNI move on this edge; return true if change successful and we stop the loop</p></li><li><p>If we find a <code>hz==0,1</code>, we loop through <code>nhz</code> to find such hybrid edge and call <code>gammaZero!</code> again</p></li><li><p>If we did a successful change, we run <code>optBL</code> again, and recheck if there are no more problems.</p></li><li><p>Returns successchange, flagh, flagt,flaghz (flag=true means no problems)</p></li><li><p>If it is the multiple alleles case, it will not try to fix <code>h==0,1;hz==0,1</code> because it can reach a case that violates the multiple alleles condition. If we add a check here, things become horribly slow and inefficient, so we just delete a hybridization that has <code>h==0,1;hz==0,1</code></p></li></ul><p>** Important**: <code>afterOptBL</code> is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call <code>afterOptBLRepeat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/snaq_optimization.jl#L608-L643">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.afterOptBLAll!-Tuple{HybridNetwork, DataCF, Integer, Bool, Float64, Float64, Bool, Vector{Int64}, Float64, Float64, Float64}" href="#SNaQ.afterOptBLAll!-Tuple{HybridNetwork, DataCF, Integer, Bool, Float64, Float64, Bool, Vector{Int64}, Float64, Float64, Float64}"><code>SNaQ.afterOptBLAll!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">afterOptBLAll!(currT, args...)</code></pre><p>Try to fix any gamma zero problem (<code>h==0,1</code>; <code>t==0</code>; <code>hz==0,1</code>) by calling <code>afterOptBLRepeat!</code>. If problems cannot be fixed, it will call <code>moveDownLevel</code> to delete the hybridization from the network. Like <code>afterOptBLAllMultipleAlleles</code>, this function is called after <code>optBL</code>.</p><p>Output: new approved network <code>currT</code> (no gammas=0.0)</p><p>Procedure:</p><p>While <code>startover=true</code> and <code>tries&lt;N</code></p><ul><li>While <code>badliks &lt; N2</code> (number of bad pseudolikelihoods are less than <code>N2</code>)<ul><li>Run <code>success = afterOptBLRepeat</code></li><li>If <code>success = true</code> (it changed something):<ul><li>If worse pseudolik, then go back to original topology <code>currT</code>, set <code>startover=true</code> and <code>badliks++</code></li><li>If better pseudolik, then check flags. If all good, then <code>startover=false</code>; otherwise <code>startover = true</code></li></ul></li><li>If <code>success = false</code> (nothing changed), then set <code>badliks=N2+1</code> (to end the while on <code>currT</code>)<ul><li>If all flags are ok, then <code>startover = false</code></li><li>If bad h or hz, then call <code>moveDownLevel</code> (delete one hybridization), and set <code>startover = true</code> (maybe deleting that hybridization did not fix other gamma zero problems)</li><li>If bad t, then set <code>startover = false</code></li></ul></li></ul></li><li>If left second while by back to original <code>currT</code>, and still bad h/hz, then move down one level, and <code>startover=true</code>; otherwise <code>startover=false</code></li></ul><p>If first while ends by <code>tries&gt;N</code>, then it checks one last time the flags, if bad h/hz will move down one level, and exit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/snaq_optimization.jl#L818-L842">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.afterOptBLRepeat!-Tuple{HybridNetwork, DataCF, Integer, Bool, Bool, Bool, Vector{Int64}}" href="#SNaQ.afterOptBLRepeat!-Tuple{HybridNetwork, DataCF, Integer, Bool, Bool, Bool, Vector{Int64}}"><code>SNaQ.afterOptBLRepeat!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">afterOptBLRepeat!</code></pre><p>Repeat <code>afterOptBL!</code>, which only does one change. Repeating multiple times is to be sure that we fix all the gamma zero problems, after every time a successful change happened. This is done only if <code>closeN=false</code>, because we would delete/add hybridizations and need to stop after tried N times. If <code>closeN=true</code> (default), then <code>afterOptBLRepeat!</code> only does one <code>afterOptBL!</code>, because in this case, only the neighbor edges need to be tested, and this would have been done already in <code>gammaZero!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/snaq_optimization.jl#L741-L752">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.calculateObsCFAll!-Tuple{DataCF, Union{Vector{Int64}, Vector{&lt;:AbstractString}}}" href="#SNaQ.calculateObsCFAll!-Tuple{DataCF, Union{Vector{Int64}, Vector{&lt;:AbstractString}}}"><code>SNaQ.calculateObsCFAll!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculateObsCFAll!(DataCF, taxa::Union{Vector{&lt;:AbstractString}, Vector{Int}})</code></pre><p>Calculate observed concordance factors: update the <code>.quartet[i].obsCF</code> values of the <code>DataCF</code> object based on its .tree vector.</p><pre><code class="nohighlight hljs">calculateObsCFAll!(vector of quartets, vector of trees, taxa)</code></pre><p>Calculate observed concordance factors: update the <code>.obsCF</code> values of the quartets, based on the trees, and returns a new <code>DataCF</code> object with these updated quartets and trees.</p><pre><code class="nohighlight hljs">calculateObsCFAll_noDataCF!(vector of quartets, vector of trees, taxa)</code></pre><p>update the <code>.obsCF</code> values of the quartets based on the trees, but returns nothing.</p><p>Warning: all these functions need input trees (without any reticulations: h=0).</p><p>See also: <a href="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/public/#PhyloNetworks.countquartetsintrees"><code>PhyloNetworks.countquartetsintrees</code></a>, which uses a faster algorithm, processing each input tree only once. <code>calculateObsCFAll_noDataCF!</code> processes each input tree <code># quartet</code> times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/readquartetdata.jl#L445-L466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.checkMapDF-Tuple{DataFrames.DataFrame}" href="#SNaQ.checkMapDF-Tuple{DataFrames.DataFrame}"><code>SNaQ.checkMapDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkMapDF(mapping_allele2species::DataFrame)</code></pre><p>Check that the data frame has one column named &quot;allele&quot; or &quot;individual&quot;, and one column named &quot;species&quot;. Output: indices of these column.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/multipleAlleles.jl#L239-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.deleteLeaf!-Tuple{PhyloNetworks.Network, AbstractString}" href="#SNaQ.deleteLeaf!-Tuple{PhyloNetworks.Network, AbstractString}"><code>SNaQ.deleteLeaf!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deleteLeaf!(net::HybridNetwork, leaf::AbstractString)
deleteLeaf!(net::Network, leaf::Node)</code></pre><p>Delete the leaf taxon from the network. The leaf argument is the name of the taxon to delete.</p><p>Warnings:</p><ul><li>requires a level-1 network with up-to-date attributes for snaq! (e.g. non-missing branch lengths, gammaz, etc.)</li><li>does not care where the root is and does not update it to a sensible location if the root is affected by the leaf removal.</li><li>does not merge edges, i.e. does not remove all nodes of degree 2. Within snaq!, this is used to extract quartets and to keep track of which edge lengths in the original network map to the quartet network.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/pseudolik.jl#L359-L373">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.gammaZero!-Tuple{HybridNetwork, DataCF, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}" href="#SNaQ.gammaZero!-Tuple{HybridNetwork, DataCF, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}"><code>SNaQ.gammaZero!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gammaZero!</code></pre><p>Try to fix a gamma zero problem (<code>h==0,1; t==0; hz==0,1</code>)</p><ol><li>First tries to do <code>changeDirection</code>: change the direction of hybrid edge</li><li>If changing the direction was successful, call <code>optBL</code> and check that the problem was fixed</li><li>If problem fixed and the pseudolik is not worse, return <code>success=true</code></li><li>If changing the direction failed (step 1) or if the problem persists (step 2 failed) or if the pseudolik got worse (step 3 failed), then call <code>moveHybrid!</code>.</li></ol><p>** Important**: Any function (<code>afterOptBL</code>) calling <code>gammaZero!</code> is assuming that it only made a change, so if the returned value is true, then a change was made, and the other function needs to run <code>optBL</code> and check that all parameters are &#39;valid&#39;. If the returned value is false, then no change was possible and we need to remove a hybridization if the problem is h==0,1; hz==0,1. If the problem is t==0, we ignore this problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/snaq_optimization.jl#L545-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.getNeighborsTarget-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#SNaQ.getNeighborsTarget-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>SNaQ.getNeighborsTarget</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getNeighborsTarget(hybrid_node, majoredge)</code></pre><p>Vector of edges that are incident to either:</p><ul><li>the node incident to <code>majoredge</code> other than <code>hybrid_node</code>, or</li><li>the tree child of <code>hybrid_node</code>.</li></ul><p>This vector of edges is used as the list of suitable neighbors of &quot;othermin&quot; to move the target of a hybrid edge, in <code>moveTargetUpdateRepeat!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/moves_snaq.jl#L657-L666">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.hybridatnode!-Tuple{HybridNetwork, Integer}" href="#SNaQ.hybridatnode!-Tuple{HybridNetwork, Integer}"><code>SNaQ.hybridatnode!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hybridatnode!(net::HybridNetwork, nodeNumber::Integer)</code></pre><p>Change the direction and status of edges in network <code>net</code>, to move the hybrid node in a cycle to the node with number <code>nodeNumber</code>. This node must be in one (and only one) cycle, otherwise an error will be thrown. Check and update the nodes&#39; field <code>inCycle</code>.</p><p>Output: <code>net</code> after hybrid modification.</p><p>Assumption: <code>net</code> must be of level 1, that is, each blob has a single cycle with a single reticulation.</p><p><strong>example</strong></p><pre><code class="language-julia hljs">net = readnewick(&quot;(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;&quot;);
using PhyloPlots
plot(net, shownodenumber=true); # to locate nodes and their numbers. D of hybrid origin
hybridatnode!(net, -4)
plot(net, shownodenumber=true); # hybrid direction reversed: now 2B of hybrid origin</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/manipulateNet.jl#L96-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.hybridatnode!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.Node}" href="#SNaQ.hybridatnode!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.Node}"><code>SNaQ.hybridatnode!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hybridatnode!(net::HybridNetwork, hybrid::Node, newNode::Node)</code></pre><p>Move the reticulation from <code>hybrid</code> to <code>newNode</code>, which must in the same cycle. <code>net</code> is assumed to be of level 1, but <strong>no checks</strong> are made and fields are supposed up-to-date.</p><p>Called by <code>hybridatnode!(net, nodenumber)</code>, which is itself called by <a href="#SNaQ.undirectedOtherNetworks-Tuple{HybridNetwork}"><code>undirectedOtherNetworks</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/manipulateNet.jl#L144-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.mapallelesCFtable!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, AbstractVector{Int64}, Bool, AbstractString}" href="#SNaQ.mapallelesCFtable!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, AbstractVector{Int64}, Bool, AbstractString}"><code>SNaQ.mapallelesCFtable!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapallelesCFtable!(quartet CF DataFrame, mapping DataFrame, columns, write?, filename)</code></pre><p>Modify (and return) the quartet concordance factor (CF) DataFrame: replace each allele name by the species name that the allele maps onto based on the mapping data frame. This mapping data frame should have columns named &quot;allele&quot; and &quot;species&quot; (see <code>rename!</code> to change column names if need be).</p><p>If <code>write?</code> is <code>true</code>, the modified data frame is written to a file named &quot;filename&quot;.</p><p>Warning: <a href="../public/#SNaQ.mapallelesCFtable-Tuple{AbstractString, AbstractString}"><code>mapallelesCFtable</code></a> takes the quartet data file as its second argument, while <code>mapallelesCFtable!</code> takes the quartet data (which it modifies) as its first argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/multipleAlleles.jl#L56-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.moveHybrid!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}" href="#SNaQ.moveHybrid!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}"><code>SNaQ.moveHybrid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moveHybrid!(net, edge, closeN, origin, N, movesgamma)</code></pre><p>Delete a hybrid, and then add a new hybrid. Attempt to fix a gamma zero problem (<code>h==0,1; t==0; hz==0,1</code>) after changing the direction of hybrid edge failed. This function is called in <code>gammaZero!</code>.</p><p>Arguments:</p><ul><li><code>closeN=true</code> will try move origin/target on all neighbors (first choose minor/major edge at random, then make list of all neighbor edges and tries to put the hybrid node in all the neighbors until successful move).   <code>closeN=false</code> will delete and add hybrid until successful move up to <code>N</code> times (this is never tested).</li><li><code>origin</code>: move the origin if true, moves the target if false. Option used to avoid coming back to propose the same network over and over.</li><li><code>movesgama</code>: vector of integers. Counts the number of times each move is proposed to fix a gamma zero situation. Proposal types and order: <code>(add, mvorigin, mvtarget, chdir, delete, nni)</code></li></ul><p>Return <code>true</code> if change was successful (not testing <code>optBL</code> again), and <code>false</code> if we could not move anything.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/snaq_optimization.jl#L490-L512">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.moveTargetUpdate!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#SNaQ.moveTargetUpdate!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>SNaQ.moveTargetUpdate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moveTargetUpdate!(net, hybrid_node, majoredge, newedge)</code></pre><p>Modify a level-1 network <code>net</code> by moving <code>majoredge</code>, which should be a hybrid edge parent of <code>hybrid_node</code>. Within SNaQ, <code>majoredge</code> is chosen by <code>chooseMinorMajor</code>.</p><ul><li>calls <code>moveTarget!(net,hybrid_node, majoredge, treeedge_belowhybrid, newedge)</code>, which does the move but does not update any attributes</li><li>updates all level-1 attributes needed for SNaQ: gammaz, containroot</li><li>un-does the move and updates if the move is invalid, through another call to <code>moveTarget!</code> but with the &quot;undo&quot; option.</li></ul><p><code>newedge</code> should be a tree edge (enforced by <code>chooseEdgeOriginTarget!</code>) adjacent to the parent node of <code>majoredge</code> or to the tree child of <code>hybrid_node</code> (enforced by <code>getNeighborsTarget</code>)</p><p>Output: tuple of 3 booleans <code>(success, flag_triangle, flag_root)</code>.</p><ul><li><code>success</code> is false if the move failed (lead to an invalid network for SNaQ)</li><li><code>flag_triangle</code> is false if <code>hasVeryBadTriangle(net)</code></li><li><code>flag_root</code> is false if the set of edges to place the root is empty</li></ul><p>If <code>success</code> is false, then the flags are not meant to be used downstream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/moves_snaq.jl#L987-L1008">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.optBL!-Tuple{HybridNetwork, DataCF, Bool, Vararg{Float64, 4}}" href="#SNaQ.optBL!-Tuple{HybridNetwork, DataCF, Bool, Vararg{Float64, 4}}"><code>SNaQ.optBL!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optBL!(
    net::HybridNetwork,
    d::DataCF,
    verbose::Bool,
    ftolRel::Float64,
    ftolAbs::Float64,
    xtolRel::Float64,
    xtolAbs::Float64
)</code></pre><p>Optimize the edge parameters (lengths and inheritance probabilities γ) of a given level-1 network, using the BOBYQA algorithm from the NLopt package. The optimum found is used to modify <code>net</code> with new edge lengths, hybrid edge γs, and minimum <code>loglik(net)</code>.</p><p><em>Warning</em>: <code>net</code> is assumed to have up-to-date and correct level-1 attributes. This is not checked for efficiency, because this function is called repeatedly inside <code>optTopLevel!</code> and <a href="../public/#SNaQ.snaq!-Tuple{HybridNetwork, DataCF}"><code>snaq!</code></a>.</p><p>Procedure:</p><ul><li><code>ht = parameters!(net)</code> extracts the vector of parameters to estimate <code>(h,t,gammaz)</code>, and sets as <code>ht(net)</code>; identifies a bad diamond I, sets <code>numht(net)</code> (vector of hybrid node numbers for h, edge numbers for t, hybrid node numbers for gammaz), and <code>index(net)</code> to keep track of the vector of parameters to estimate</li><li><code>extractQuartet!(net,d)</code> does the following for all quartets in <code>d.quartet</code>:<ul><li>Extract quartet by deleting all leaves not in q -&gt; create <code>QuartetNetwork</code> object saved in <code>q.qnet</code></li><li>This network is ugly and does not have edges collapsed. This is done to keep a one-to-one correspondence between the edges in <code>q.qnet</code> and the edges in <code>net</code> (if we remove nodes with only two edges, we will lose this correspondence)</li><li>Calculate expected CF with <code>calculateExpCFAll</code> for a copy of <code>q.qnet</code>. We do this copy because we want to keep <code>q.qnet</code> as it is (without collapsed edges into one). The function will then save the <code>expCF</code> in <code>q.qnet.expCF</code></li></ul></li><li><code>calculateExpCFAll!(qnet)</code> will<ul><li>identify the type of quartet as type 1 (equivalent to a tree) or type 2 (minor CF different). Here the code will first clean up any hybrid node by removing nodes with only two edges before identifying the <code>qnet</code> (because identification depends on neighbor nodes to hybrid node); later, set <code>qnet.which</code> (1 or 2), <code>node.prev</code> (neighbor node to hybrid node), updates <code>k(node)</code> (number of nodes in hybridization cycle, this can change after deleting the nodes with only two edges), <code>typeHyb(node)</code> (1,2,3,4,5 depending on the number of nodes in the hybridization cycle and the origin/target of the minor hybrid edge; this attribute is never used).</li><li>eliminate hybridization: this will remove type 1 hybridizations first. If <code>qnet.which=1</code>, then the <code>qnet</code> is similar to a tree quartet, so it will calculate the internal length of the tree quartet: <code>qnet.t1</code>.</li><li>update split for <code>qnet.which=1</code>, to determine which taxa are together. For example, for the quartet 12|34, the split is [1,1,2,2] or [2,2,1,1], that is, taxon 1 and 2 are on the same side of the split. This will update <code>qnet.split</code></li><li>update formula for <code>qnet.which=1</code> to know the order of minorCF and majorCF in the vector <code>qnet.expCF</code>. That is, if the quartet is 1342 (order in <code>qnet.quartet.taxon</code>), then the expected CF should match the observed CF in 13|42, 14|32, 12|34 and the <code>qnet</code> is 12|34 (given by <code>qnet.split</code>), <code>qnet.formula</code> will be [2,2,1] minor, minor, major</li><li><code>calculateExpCF!(qnet)</code> for <code>qnet.which=1</code>, it will do <code>1-2/3exp(-qnet.t1)</code> if <code>qnet.formula[i]==1</code>, and <code>1/3exp(qnet.t1)</code> if <code>qnet.formula[i]==2</code>. For <code>qnet.which=2</code>, we need to make sure that there is only one hybrid node, and compute the major, minor1,minor2 expected CF in the order 12|34, 13|24, 14|23 of the taxa in <code>qnet.quartet.taxon</code></li></ul></li></ul><p>Then we create a <code>NLopt</code> object with algorithm BOBYQA and k parameters (length of ht). We define upper and lower bounds and define the objective function that should only depend on <code>x=(h,t,gz)</code> and g (gradient, which we do not have, but still need to put as argument).</p><p>The objective function <code>obj(x,g)</code> calls</p><ul><li><code>calculateExpCFAll!(d,x,net)</code> needs to be run after <code>extractQuartet(net,d)</code> that will update <code>q.qnet</code> for all quartet.  Assumes that <code>qnet.indexht</code> is updated already: we only need to do this at the beginning of <code>optBL!</code> because the topology is fixed at this point)<ul><li>First it will update the edge lengths according to x</li><li>If the <code>q.qnet.changed=true</code> (that is, any of <code>qnet</code> branches changed value), we need to call <code>calculateExpCFAll!(qnet)</code> on a copy of <code>q.qnet</code> (again because we want to leave <code>q.qnet</code> with the edge correspondence to <code>net</code>)</li></ul></li><li><code>update!(net,x)</code> simply saves the new x in <code>ht(net)</code></li></ul><p>Finally, after calling <code>NLopt.optimize</code>, <code>loglik(net)</code> and <code>ht(net)</code> are updated with the optimum score and parameter values that were found. After <code>optBL</code>, we want to call <code>afterOptBLAll</code> (or <code>afterOptBLAllMultipleAlleles</code>) to check if there are <code>h==0,1</code>; <code>t==0</code>; <code>hz==0,1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/snaq_optimization.jl#L285-L344">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.optTopLevel!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, IO, Bool}" href="#SNaQ.optTopLevel!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, IO, Bool}"><code>SNaQ.optTopLevel!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optTopLevel!(currT, args...)</code></pre><p>Does most of the heavy-lifting of <code>snaq!</code>, to search the space of networks with at most <code>hmax</code> hybrid nodes. It optimizes the pseudolikelihood starting from network <code>currT</code>, and returns the best network. Unlike <code>snaq!</code>, it assumes that the starting topology <code>currT</code> is of level-1, and has all the attributes correctly updated. <code>currT</code> is modified.</p><p>Input parameters:</p><ul><li>Starting topology <code>currT</code>, input data <code>DataCF</code> <code>d</code>, maximum number of hybridizations <code>hmax</code></li><li>Numerical optimization parameters:<ul><li><code>liktolAbs</code>: stop the search if the change in loglik is smaller (in absolute value)</li><li><code>Nfail</code>: number of failure networks with lower loglik before aborting</li><li><code>ftolRel, ftolAbs, xtolRel, xtolAbs</code>: to stop the optimization of  edge parameters on each fixed topology</li></ul></li><li>Print parameters: <code>verbose, logfile, writelog</code></li><li>Parameters to tune the search in space of networks: <code>closeN=true</code> only propose move origin/target to neighbor edges (coded, but not tested with <code>closeN=false</code>), <code>Nmov0</code> vector with maximum number of trials allowed per type of move <code>(add, mvorigin, mvtarget, chdir, delete, nni)</code>, by default computed inside with coupon’s collector formulas</li></ul><p>The optimization procedure keeps track of</p><ul><li><code>movescount</code>: count of proposed moves,</li><li><code>movesgamma</code>: count of proposed moves to fix a gamma zero situation (see below for definition of this situation),</li><li><code>movesfail</code>: count of failed moves by violation of level-1 network (<code>inCycle</code> attribute) or worse pseudolikelihood than current,</li><li><code>failures</code>: number of failed proposals that had a worse pseudolikelihood</li></ul><p>Optimization procedure:</p><p>While the difference between current loglik and proposed loglik is greater than <code>liktolAbs</code>, or <code>failures&lt;Nfail</code>, or <code>stillmoves=true</code>:</p><ul><li><p><code>Nmov</code> is a vector with the maximum number of trial per move type: <code>(add,mvorigin,mvtarget,chdir,delete,nni)</code>. <code>Nmov</code> is updated based on <code>newT</code>. The type of move proposed will depend on <code>newT</code> (which is the same as <code>currT</code> at this point). For example, if <code>currT</code> is a tree, we cannot propose move origin/target.</p></li><li><p><code>move = whichMove</code> selects randomly a type of move, depending on <code>Nmov,movesfail,hmax,newT</code> with weights 1/5 by default for all, and 0 for delete. These weights are adjusted depending on <code>newT.numhybrids</code> and <code>hmax</code>. If <code>newT.numhybrids</code> is far from <code>hmax</code>, we give higher probability to adding a new hybrid (we want to reach the <code>hmax</code> sooner, maybe not the best strategy, easy to change).  Later, we adjust the weights by <code>movesfail</code> (first, give weight of 0 if <code>movesfail[i]&gt;Nmov[i]</code>, that is, if we reached the maximum possible number of moves allowed for a certain type) and then increase the probability of the other moves.  So, unless one move has <code>w=0</code>, nothing changes. This could be improved by using the outlier quartets to guide the proposal of moves.</p></li><li><p><code>whichMove</code> will choose a move randomly from the weights, it will return <code>none</code> if no more moves allowed, in which case, the optimization ends</p></li><li><p><code>flag=proposedTop!(move, newT)</code> will modify <code>newT</code> based on <code>move</code>. The function <code>proposedTop</code> will return <code>flag=true</code> if the move was successful (the move succeeded by <code>inCycle</code>, <code>containroot</code>, available edge to make the move (more details in <code>proposedTop</code>)). If <code>flag=false</code>, then <code>newT</code> is cleaned, except for the case of multiple alleles. The function <code>proposedTop</code> keeps count of <code>movescount</code> (successful move), <code>movesfail</code> (unsuccessful move),</p><p>Options:</p><p><code>random=true</code>: moves major/minor hybrid edge with prob h,1-h, respectively</p><p><code>N=10</code>: number of trials for NNI edge.</p></li><li><p>if(flag) Optimize branch lengths with <code>optBL</code></p><p>If <code>loglik(newT)</code> is better than <code>loglik(currT)</code> by <code>liktolAbs</code>, jump to <code>newT</code> (<code>accepted=true</code>) and fix <code>gamma=0, t=0</code> problems (more info on <code>afterOptBL</code>)</p><p>If(accepted)   <code>failures=0</code>, <code>movesfail=zeros</code>, <code>movescount</code> for successful move +1</p></li></ul><p>end while</p><p>After choosing the best network <code>newT</code>, we do one last more thorough optimization of branch lengths with <code>optBL</code>, we change non identifiable branch lengths to -1 (only in debug mode) and return <code>newT</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/snaq_optimization.jl#L1263-L1329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.optTopRun1!-Tuple{HybridNetwork, Any, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, IO, Bool, Float64}" href="#SNaQ.optTopRun1!-Tuple{HybridNetwork, Any, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, IO, Bool, Float64}"><code>SNaQ.optTopRun1!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optTopRun1!(net, liktolAbs, Nfail, d::DataCF, hmax, etc.)</code></pre><p>The function will run 1 run by modifying the starting topology and calling <code>optTopLevel</code>. See <a href="#SNaQ.optTopRuns!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, AbstractString, AbstractString, Integer, Float64}"><code>optTopRuns!</code></a> for a roadmap.</p><p><code>probST</code> (default in snaq is 0.3) is the probability of starting one run at the same input tree. So, with probability <code>1-probST</code>, we will change the topology by a NNI move on a tree edge without neighbor hybrid. If the starting topology is a network, then with probability <code>1-probST</code> it will also modify one randomly chosen hybrid edge: with prob 0.5, the function will move origin, with prob 0.5 will do move target.</p><p>If there are multiple alleles (<code>d.repSpecies</code> not empty), then the function has to check that the starting topology does not violate the multiple alleles condition.</p><p>After modifying the starting topology with NNI and/or move origin/target, <code>optTopLevel</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/snaq_optimization.jl#L1853-L1872">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.optTopRuns!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, AbstractString, AbstractString, Integer, Float64}" href="#SNaQ.optTopRuns!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, AbstractString, AbstractString, Integer, Float64}"><code>SNaQ.optTopRuns!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Road map for various functions behind <a href="../public/#SNaQ.snaq!-Tuple{HybridNetwork, DataCF}"><code>snaq!</code></a></p><pre><code class="nohighlight hljs">snaq!
optTopRuns!
optTopRun1!
optTopLevel!
optBL!</code></pre><p>All return their optimized network.</p><ul><li><a href="../public/#SNaQ.snaq!-Tuple{HybridNetwork, DataCF}"><code>snaq!</code></a> calls <code>optTopRuns!</code> once, after a deep copy of the starting network. If the data contain multiple alleles from a given species, <code>snaq!</code> first expands the leaf for that species into 2 separate leaves, and merges them back into a single leaf after calling <code>optTopRuns!</code>.</li><li><code>optTopRuns!</code> calls <a href="#SNaQ.optTopRun1!-Tuple{HybridNetwork, Any, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, IO, Bool, Float64}"><code>optTopRun1!</code></a> several (<code>nrun</code>) times. assumes level-1 network with &gt;0 branch lengths. assumes same tips in network as in data: i.e. 2 separate tips per species                                          that has multiple alleles. each call to <code>optTopRun1!</code> gets the same starting network.</li><li><code>optTopRun1!</code> calls <code>optTopLevel!</code> once, after deep copying + changing the starting network slightly.</li><li><code>optTopLevel!</code> calls <code>optBL!</code> various times and proposes new network with various moves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/snaq_optimization.jl#L1620-L1643">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.proposedTop!-Tuple{Integer, HybridNetwork, Bool, Integer, Integer, Vector{Int64}, Vector{Int64}, Bool}" href="#SNaQ.proposedTop!-Tuple{Integer, HybridNetwork, Bool, Integer, Integer, Vector{Int64}, Vector{Int64}, Bool}"><code>SNaQ.proposedTop!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">proposedTop!(move,newT,random,count,N,movescount,movesfail,multall)</code></pre><p>Change the current network <code>newT</code> by a given <code>move</code>, and check that the move was successful (correct attributes). If not successful, <code>newT</code> is changed back to its original state, except for the case of multiple alleles.</p><p><strong>Note</strong> that the update of attributes by each move is not done in all the network, but only in the local edges that were changed by the move. This is efficient (and makes a move easy to undo), but makes the code of each move function very clunky.</p><p>Arguments:</p><ul><li><code>move</code> chosen from <code>whichMove</code> as described in <code>optTopLevel!</code></li><li><code>newT</code> is the topology that will be modified inside with the move</li><li><code>random=true</code>: choose the minor hybrid edge with probability 1-h, and major edge with probability h. If <code>false</code>: always choose the minor hybrid edge</li><li><code>count</code>: simply which likelihood step we are in, in the optimization at <code>optTopLevel!</code></li><li><code>N</code>: number of attempts for NNI moves</li><li><code>movescount</code> and <code>movesfail</code>: vector of counts of number of moves proposed. move types and order: <code>(add,mvorigin,mvtarget,chdir,delete,nni)</code>.</li><li><code>multall=true</code> if multiple alleles case: we need to check if the move did not violate the multiple alleles condition (sister alleles together and no gene flow into the alleles). This is inefficient because we are proposing moves that we can reject later, instead of being smart about the moves we propose: for example, move origin/target could rule out some neighbors that move gene flow into the alleles, the same for add hybridization; nni move can check if it is trying to separate the alleles)</li></ul><p>Moves:</p><ul><li><p><code>addHybridizationUpdate(newT,N)</code>: will choose a partition first (to avoid choosing edges that will create a non level-1 network) will choose two edges from this partition randomly, will not allow two edges in a cherry (non-identifiable), or sister edges that are not identifiable (the blacklist was a way to keep track of &quot;bad edges&quot; were we should not waste time trying to put hybridizations, it has never been used nor tested). Also choose gamma from U(0,0.5). The &quot;Update&quot; in the function name means that it creates the new hybrid, and also updates all the attributes of <code>newT</code></p></li><li><p><code>node = chooseHybrid(newT)</code> choose a hybrid randomly for the next moves:</p></li><li><p><code>moveOriginUpdateRepeat!(newT,node,random)</code> will choose randomly the minor/major hybrid edge to move (if <code>random=true</code>); will get the list of all neighbor edges where to move the origin, will move the origin and update all the attributes and check if the move was successful (not conflicting attributes); if not, will undo the move, and try with a different neighbor until it runs out of neighbors. Return true if the move was successful.</p></li><li><p><code>moveTargetUpdateRepeat!(newT,node,random)</code> same as move origin but moving the target</p></li><li><p><code>changeDirectionUpdate!(newT,node,random)</code> chooses minor/major hybrid edge at random (if `random=true), and changes the direction, and updates all the attributes. Checks if the move was successful (returns true), or undoes the change and returns false.</p></li><li><p><code>deleteHybridizationUpdate!(newT,node)</code> removes the hybrid node, updates the attributes, no need to check any attributes, always successful move</p></li><li><p>NNIRepeat!(newT,N) choose an edge for nni that does not have a neighbor hybrid. It will try to find such an edge N times, and if it fails, it will return false (unsuccessful move). N=10 by default. If N=1, it rarely finds such an edge if the network is small or complex. The function cannot choose an external edge. it will update locally the attributes.</p></li></ul><p>** Important**: All the moves undo what they did if the move was not successful, so at the end you either have a <code>newT</code> with a new move and with all good attributes, or the same <code>newT</code> that started. This is important to avoid having to do deepcopy of the network before doing the move. Also, after each move, when we update the attributes, we do not update the attributes of the whole network, we only update the attributes of the edges that were affected by the move. This saves time, but makes the code quite clunky. Only the case of multiple alleles the moves does not undo what it did, because it finds out that it failed after the function is over, so just need to treat this case special.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/snaq_optimization.jl#L1101-L1180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.readInputData-Tuple{AbstractString, AbstractString, Symbol, Integer, Bool, AbstractString, Bool, Bool}" href="#SNaQ.readInputData-Tuple{AbstractString, AbstractString, Symbol, Integer, Bool, AbstractString, Bool, Bool}"><code>SNaQ.readInputData</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readInputData(trees, quartetfile, whichQuartets, numQuartets, writetable, tablename, writeQfile, writesummary)
readInputData(trees, whichQuartets, numQuartets, taxonlist,   writetable, tablename, writeQfile, writesummary)</code></pre><p>Read gene trees and calculate the observed quartet concordance factors (CF), that is, the proportion of genes (and the number of genes) that display each quartet for a given list of four-taxon sets.</p><p>Input:</p><ul><li><code>trees</code>: name of a file containing a list of input gene trees, or vector of trees (<code>HybridNetwork</code> objects)</li></ul><p>Optional arguments (defaults):</p><ul><li><code>quartetfile</code>: name of a file containing a list of quartets, or more precisely, a list of four-taxon sets</li><li><code>whichQuartets</code> (<code>:all</code>): which quartets to sample. <code>:all</code> for all of them, <code>:rand</code> for a random sample.</li><li><code>numQuartets</code>: number of quartets in the sample. default: total number of quartets if <code>whichQuartets=:all</code> and 10% of total if <code>whichQuartets=:rand</code></li><li><code>taxonlist</code> (all in the input gene trees): If <code>taxonlist</code> is used, <code>whichQuartets</code> will consist of <em>all</em> sets of 4 taxa in the <code>taxonlist</code>. </li><li><code>writetable</code> (true): write the table of observed CF?</li><li><code>tablename</code> (&quot;tableCF.txt&quot;): if <code>writetable</code> is true, the table of observed CFs is write to file <code>tablename</code></li><li><code>writeQfile</code> (false): write intermediate file with sampled quartets?</li><li><code>writesummary</code> (true): write a summary file? if so, the summary will go in file &quot;summaryTreesQuartets.txt&quot;.</li></ul><p>Uses <a href="#SNaQ.calculateObsCFAll!-Tuple{DataCF, Union{Vector{Int64}, Vector{&lt;:AbstractString}}}"><code>calculateObsCFAll!</code></a>, which implements a slow algorithm.</p><p>See also: <a href="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/public/#PhyloNetworks.countquartetsintrees"><code>PhyloNetworks.countquartetsintrees</code></a>, which uses a much faster algorithm; <a href="../public/#SNaQ.readtrees2CF-Tuple{AbstractString}"><code>readtrees2CF</code></a>, which is an exported and user-friendly re-naming of <code>readInputData</code>, and <a href="../public/#SNaQ.readtableCF-Tuple{AbstractString}"><code>readtableCF</code></a> to read a table of quartet CFs directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/readquartetdata.jl#L528-L564">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.sameTaxa-Tuple{Quartet, HybridNetwork}" href="#SNaQ.sameTaxa-Tuple{Quartet, HybridNetwork}"><code>SNaQ.sameTaxa</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sameTaxa(Quartet, HybridNetwork)</code></pre><p>Return <code>true</code> if all taxa in the quartet are represented in the network, <code>false</code> if one or more taxa in the quartet does not appear in the network.</p><p>warning: the name can cause confusion. A more appropriate name might be &quot;in&quot;, or &quot;taxain&quot;, or &quot;taxonsubset&quot;, or etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/readquartetdata.jl#L383-L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.sampleCFfromCI" href="#SNaQ.sampleCFfromCI"><code>SNaQ.sampleCFfromCI</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sampleCFfromCI(data frame, seed=0)
sampleCFfromCI!(data frame, seed=0)</code></pre><p>Read a data frame containing CFs and their credibility intervals, and sample new obsCF uniformly within the CIs. These CFs are then rescaled to sum up to 1 for each 4-taxon sets. Return a data frame with taxon labels in first 4 columns, sampled obs CFs in columns 5-7 and credibility intervals in columns 8-13.</p><ul><li>The non-modifying function creates a new data frame (with re-ordered columns) and returns it. If <code>seed=-1</code>, the new df is a deep copy of the input df, with no call to the random number generator. Otherwise, <code>seed</code> is passed to the modifying function.</li><li>The modifying function overwrites the input data frame with the sampled CFs and returns it. If <code>seed=0</code>, the random generator is seeded from the clock. Otherwise the random generator is seeded using <code>seed</code>.</li></ul><p>Warning: the modifying version does <em>not</em> check the data frame: assumes correct columns.</p><p>optional argument: <code>delim=&#39;,&#39;</code> by default: how columns are delimited.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/bootstrap.jl#L7-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}" href="#SNaQ.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>SNaQ.setGammaBLfromGammaz!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setGammaBLfromGammaz!(node, network)</code></pre><p>Update the γ values of the two sister hybrid edges in a bad diamond I, given the <code>gammaz</code> values of their parent nodes, and update the branch lengths t1 and t2 of their parent edges (those across from the hybrid nodes), in such a way that t1=t2 and that these branch lengths and γ values are consistent with the <code>gammaz</code> values in the network.</p><p>Similar to the first section of <a href="#SNaQ.undoGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>undoGammaz!</code></a>, but does not update anything else than γ and t&#39;s. Unlike <code>undoGammaz!</code>, no error if non-hybrid <code>node</code> or not at bad diamond I.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/auxiliary.jl#L144-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.setLength!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Number}" href="#SNaQ.setLength!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Number}"><code>SNaQ.setLength!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setLength!(edge, newlength)`</code></pre><p>Set the length of <code>edge</code>, and set <code>edge.y</code> and <code>edge.z</code> accordingly. Warning: specific to <code>SNaQ.jl</code>. Consider <a href="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/public/#PhyloNetworks.setlengths%21-Tuple%7BVector%7BPhyloNetworks.EdgeT%7BPhyloNetworks.Node%7D%7D%2C%20AbstractVector%7D"><code>PhyloNetworks.setlengths!</code></a> from <code>PhyloNetworks</code> for a more generic tool.</p><ul><li>The new length is censored to 10: if the new length is above 10, the edge&#39;s length will be set to 10. Lengths are interpreted in coalescent units, and 10 is close to infinity: near perfect gene tree concordance. 10 is used as an upper limit to coalescent units that can be reliably estimated.</li><li>The new length is allowed to be negative, but must be greater than -log(1.5), to ensure that the major quartet concordance factor (1 - 2/3 exp(-length)) is &gt;= 0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/auxiliary.jl#L126-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.setNonIdBL!-Tuple{HybridNetwork}" href="#SNaQ.setNonIdBL!-Tuple{HybridNetwork}"><code>SNaQ.setNonIdBL!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setNonIdBL!(net)</code></pre><p>Set non-identifiable edge branch lengths to -1.0 (i.e. missing) for a level-1 network <code>net</code>, except for edges in</p><ul><li>a good triangle: the edge below the hybrid is constrained to 0.</li><li>a bad diamond II: the edge below the hybrid is constrained to 0</li><li>a bad diamond I: the edges across from the hybrid node have non identifiable lengths but are kept, because the two γ*(1-exp(-t)) values are identifiable.</li></ul><p>will break if <code>inCycle</code> attributes are not initialized (at -1) or giving a correct node number.</p><p>see <a href="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/internals/#PhyloNetworks.Node"><code>PhyloNetworks.Node</code></a> for the meaning of boolean attributes <code>isBadTriangle</code> (which corresponds to a &quot;good&quot; triangle above), <code>isBadDiamondI</code> and <code>isBadDiamondII</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/descriptive.jl#L61-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.sorttaxa!-Tuple{DataCF}" href="#SNaQ.sorttaxa!-Tuple{DataCF}"><code>SNaQ.sorttaxa!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sorttaxa!(DataFrame, columns)</code></pre><p>Reorder the 4 taxa and reorders the observed concordance factors accordingly, on each row of the data frame. If <code>columns</code> is ommitted, taxon names are assumed to be in columns 1-4 and CFs are assumed to be in columns 5-6 with quartets in this order: <code>12_34</code>, <code>13_24</code>, <code>14_23</code>. Does <strong>not</strong> reorder credibility interval values, if present.</p><pre><code class="nohighlight hljs">sorttaxa!(DataCF)
sorttaxa!(Quartet, permutation_tax, permutation_cf)</code></pre><p>Reorder the 4 taxa in each element of the DataCF <code>quartet</code>. For a given Quartet, reorder the 4 taxa in its fields <code>taxon</code> and <code>qnet.quartetTaxon</code> (if non-empty) and reorder the 3 concordance values accordingly, in <code>obsCF</code> and <code>qnet.expCF</code>.</p><p><code>permutation_tax</code> and <code>permutation_cf</code> should be vectors of short integers (Int8) of length 4 and 3 respectively, whose memory allocation gets reused. Their length is <em>not checked</em>.</p><p><code>qnet.names</code> is unchanged: the order of taxon names here relates to the order of nodes in the network (???)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/auxiliary.jl#L359-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.taxadiff-Tuple{Vector{Quartet}, HybridNetwork}" href="#SNaQ.taxadiff-Tuple{Vector{Quartet}, HybridNetwork}"><code>SNaQ.taxadiff</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">taxadiff(Vector{Quartet}, network; multiplealleles=true)
taxadiff(DataCF, network; multiplealleles=true)</code></pre><p>Return 2 vectors:</p><ul><li>taxa in at least 1 of the quartets but not in the network, and</li><li>taxa in the network but in none of the quartets.</li></ul><p>When <code>multiplealleles</code> is true, the taxon names that end with &quot;__2&quot; are ignored in the quartets: they are not expected to appear in the networks that users give as input, or get as output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/readquartetdata.jl#L400-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.traverseContainRoot!-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Bool}}" href="#SNaQ.traverseContainRoot!-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Bool}}"><code>SNaQ.traverseContainRoot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">updateContainRoot!(HybridNetwork, Node)
traverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})</code></pre><p>The input <code>node</code> to <code>updateContainRoot!</code> must be a hybrid node (can come from PhyloNetworks.searchHybridNode). <code>updateContainRoot!</code> starts at the input node and calls <code>traverseContainRoot!</code>, which traverses the network recursively. By default, containroot attributes of edges are true. Changes <code>containroot</code> to false for all the visited edges: those below the input node, but not beyond any other hybrid node.</p><p><code>updateContainRoot!</code> Returns a <code>flag</code> and an array of edges whose containroot has been changed from true to false. <code>flag</code> is false if the set of edges to place the root is empty</p><p>In <code>traverseContainRoot!</code>, <code>rightDir</code> turns false if hybridizations have incompatible directions (vector of length 1, to be modified).</p><p>Warning:</p><ul><li>does <em>not</em> update <code>containroot</code> of minor hybrid edges.</li><li>assumes correct <code>ismajor</code> attributes: to stop the recursion at minor hybrid edges.</li><li>assumes correct hybrid attributes of both nodes &amp; edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).</li></ul><p><code>rightDir</code>: vector of length 1 boolean, to be mutable and modified by the function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/update.jl#L83-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.undirectedOtherNetworks-Tuple{HybridNetwork}" href="#SNaQ.undirectedOtherNetworks-Tuple{HybridNetwork}"><code>SNaQ.undirectedOtherNetworks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">undirectedOtherNetworks(net::HybridNetwork)</code></pre><p>Return a vector of HybridNetwork objects, obtained by switching the placement of each hybrid node to other nodes inside its cycle. This amounts to changing the direction of a gene flow event (recursively to move around the whole cycle of each reticulation).</p><p>Optional argument: <code>outgroup</code>, as a String. If an outgroup is specified, then networks conflicting with the placement of the root are avoided.</p><p>Assumptions: <code>net</code> is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. All level-1 fields of <code>net</code> are assumed up-to-date.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; net = readnewick(&quot;(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;&quot;);
julia&gt; vnet = undirectedOtherNetworks(net)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/manipulateNet.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.undoGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}" href="#SNaQ.undoGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>SNaQ.undoGammaz!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">undoGammaz!(node, network)</code></pre><p>Undo <code>updateGammaz!</code> for the 2 cases: bad diamond I,II. <code>node</code> should be a hybrid node. Set length to edges that were not identifiable and change edges&#39; <code>gammaz</code> attribute to -1.0. Recalculate branch lengths in terms of <code>gammaz</code>.   <em>warning</em>: needs to know <code>incycle</code> attributes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/undo.jl#L40-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.updateBL!-Tuple{HybridNetwork, DataCF}" href="#SNaQ.updateBL!-Tuple{HybridNetwork, DataCF}"><code>SNaQ.updateBL!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">updateBL!(net::HybridNetwork, d::DataCF)</code></pre><p>Update internal branch lengths of <code>net</code> based on the average quartet concordance factor (CF) across all quartets that exactly correspond to a given branch: new branch length = <code>-log(3/2(1-mean(CF observed in d)))</code>. <code>net</code> is assumed to be a tree, such that the above equation holds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/readquartetdata.jl#L826-L833">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.updateContainRoot!" href="#SNaQ.updateContainRoot!"><code>SNaQ.updateContainRoot!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">updateContainRoot!(HybridNetwork, Node)
traverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})</code></pre><p>The input <code>node</code> to <code>updateContainRoot!</code> must be a hybrid node (can come from PhyloNetworks.searchHybridNode). <code>updateContainRoot!</code> starts at the input node and calls <code>traverseContainRoot!</code>, which traverses the network recursively. By default, containroot attributes of edges are true. Changes <code>containroot</code> to false for all the visited edges: those below the input node, but not beyond any other hybrid node.</p><p><code>updateContainRoot!</code> Returns a <code>flag</code> and an array of edges whose containroot has been changed from true to false. <code>flag</code> is false if the set of edges to place the root is empty</p><p>In <code>traverseContainRoot!</code>, <code>rightDir</code> turns false if hybridizations have incompatible directions (vector of length 1, to be modified).</p><p>Warning:</p><ul><li>does <em>not</em> update <code>containroot</code> of minor hybrid edges.</li><li>assumes correct <code>ismajor</code> attributes: to stop the recursion at minor hybrid edges.</li><li>assumes correct hybrid attributes of both nodes &amp; edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).</li></ul><p><code>rightDir</code>: vector of length 1 boolean, to be mutable and modified by the function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/update.jl#L83-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.writenewick_level1-Tuple{HybridNetwork}" href="#SNaQ.writenewick_level1-Tuple{HybridNetwork}"><code>SNaQ.writenewick_level1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writenewick_level1(net::HybridNetwork)</code></pre><p>Write the extended Newick parenthetical format of a level-1 network object with many optional arguments (see below). Makes a deep copy of net: does <em>not</em> modify <code>net</code>.</p><ul><li>di=true: write in format for Dendroscope (default false)</li><li>namelabel=true: If <code>namelabel</code> is true, taxa are labelled by their names;</li></ul><p>otherwise taxa are labelled by their numbers (unique identifiers).</p><ul><li>outgroup (string): name of outgroup to root the tree/network. if &quot;none&quot; is given, the root is placed wherever possible.</li><li>printID=true, only print branch lengths for identifiable egdes according to the snaq estimation procedure (default false) (true inside of <code>snaq!</code>.)</li><li>round: rounds branch lengths and heritabilities γ (default: true)</li><li>digits: digits after the decimal place for rounding (defult: 3)</li><li>string: if true (default), returns a string, otherwise returns an IOBuffer object.</li><li>multall: (default false). set to true when there are multiple alleles per population.</li></ul><p>The topology may be written using a root different than net.rooti, if net.rooti is incompatible with one of more hybrid node. Missing hybrid names are written as &quot;#Hi&quot; where &quot;i&quot; is the hybrid node number if possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/readwrite.jl#L312-L337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.fRel" href="#SNaQ.fRel"><code>SNaQ.fRel</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Default values for tolerance parameters used in the optimization of branch lengths and γ&#39;s (<code>fAbs</code>, <code>fRel</code>, <code>xAbs</code>, <code>xRel</code>) and acceptance of topologies (<code>likAbs</code>, <code>numFails</code>).</p><p>Below, PN refers to PhyloNetworks.jl, which contained <code>snaq!</code> up until PN v0.16. Starting with PN v0.17, <code>snaq!</code> is part of this package SNaQ.jl.</p><table><tr><th style="text-align: right">pkg version</th><th style="text-align: right">fRel</th><th style="text-align: right">fAbs</th><th style="text-align: right">xRel</th><th style="text-align: right">xAbs</th><th style="text-align: right">numFails</th><th style="text-align: right">likAbs</th><th style="text-align: right">multiplier</th></tr><tr><td style="text-align: right">SNaQ v0.1</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-2</td><td style="text-align: right">1e-3</td><td style="text-align: right">75</td><td style="text-align: right">1e-6</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">PN v0.5.1</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-2</td><td style="text-align: right">1e-3</td><td style="text-align: right">75</td><td style="text-align: right">1e-6</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">PN v0.3.0</td><td style="text-align: right">1e-5</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-3</td><td style="text-align: right">1e-4</td><td style="text-align: right">100</td><td style="text-align: right">0.01</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">PN v0.0.1</td><td style="text-align: right">1e-5</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-3</td><td style="text-align: right">1e-4</td><td style="text-align: right">100</td><td style="text-align: right"></td><td style="text-align: right">10000</td></tr><tr><td style="text-align: right">PN older</td><td style="text-align: right">1e-12</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-10</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr></table><p>v0.5.1: based on Nan Ji&#39;s work. same xAbs and xRel as in phylonet (as of 2015). earlier: a <code>multiplier</code> was used; later: <code>likAbs</code> corresponds to <code>multiplier*fAbs</code>. &quot;older&quot;: values from GLM.jl, Prof Bates</p><p>Default values used on a <em>single</em> topology to optimize branch lengths and gammas, at the very end of snaq!.</p><table><tr><th style="text-align: right">pkg version</th><th style="text-align: right">fRelBL</th><th style="text-align: right">fAbsBL</th><th style="text-align: right">xRelBL</th><th style="text-align: right">xAbsBL</th></tr><tr><td style="text-align: right">SNaQ v0.1</td><td style="text-align: right">1e-12</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-10</td></tr><tr><td style="text-align: right">PN v0.0.1</td><td style="text-align: right">1e-12</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-10</td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/7b5457aed10ad5ba3aea35fdd9858176686f3268/src/snaq_optimization.jl#L8-L35">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#SNaQ.fRel"><code>SNaQ.fRel</code></a></li><li><a href="#SNaQ.QuartetNetwork"><code>SNaQ.QuartetNetwork</code></a></li><li><a href="#PhyloNetworks.printedges-Tuple{IO, SNaQ.QuartetNetwork}"><code>PhyloNetworks.printedges</code></a></li><li><a href="#PhyloNetworks.tablequartetCF-Tuple{Vector{Quartet}}"><code>PhyloNetworks.tablequartetCF</code></a></li><li><a href="#SNaQ.afterOptBL!-Tuple{HybridNetwork, DataCF, Bool, Bool, Bool, Integer, Vector{Int64}}"><code>SNaQ.afterOptBL!</code></a></li><li><a href="#SNaQ.afterOptBLAll!-Tuple{HybridNetwork, DataCF, Integer, Bool, Float64, Float64, Bool, Vector{Int64}, Float64, Float64, Float64}"><code>SNaQ.afterOptBLAll!</code></a></li><li><a href="#SNaQ.afterOptBLRepeat!-Tuple{HybridNetwork, DataCF, Integer, Bool, Bool, Bool, Vector{Int64}}"><code>SNaQ.afterOptBLRepeat!</code></a></li><li><a href="#SNaQ.calculateObsCFAll!-Tuple{DataCF, Union{Vector{Int64}, Vector{&lt;:AbstractString}}}"><code>SNaQ.calculateObsCFAll!</code></a></li><li><a href="#SNaQ.checkMapDF-Tuple{DataFrames.DataFrame}"><code>SNaQ.checkMapDF</code></a></li><li><a href="#SNaQ.deleteLeaf!-Tuple{PhyloNetworks.Network, AbstractString}"><code>SNaQ.deleteLeaf!</code></a></li><li><a href="#SNaQ.gammaZero!-Tuple{HybridNetwork, DataCF, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}"><code>SNaQ.gammaZero!</code></a></li><li><a href="#SNaQ.getNeighborsTarget-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>SNaQ.getNeighborsTarget</code></a></li><li><a href="#SNaQ.hybridatnode!-Tuple{HybridNetwork, Integer}"><code>SNaQ.hybridatnode!</code></a></li><li><a href="#SNaQ.hybridatnode!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.Node}"><code>SNaQ.hybridatnode!</code></a></li><li><a href="#SNaQ.mapallelesCFtable!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, AbstractVector{Int64}, Bool, AbstractString}"><code>SNaQ.mapallelesCFtable!</code></a></li><li><a href="#SNaQ.moveHybrid!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}"><code>SNaQ.moveHybrid!</code></a></li><li><a href="#SNaQ.moveTargetUpdate!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>SNaQ.moveTargetUpdate!</code></a></li><li><a href="#SNaQ.optBL!-Tuple{HybridNetwork, DataCF, Bool, Vararg{Float64, 4}}"><code>SNaQ.optBL!</code></a></li><li><a href="#SNaQ.optTopLevel!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, IO, Bool}"><code>SNaQ.optTopLevel!</code></a></li><li><a href="#SNaQ.optTopRun1!-Tuple{HybridNetwork, Any, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, IO, Bool, Float64}"><code>SNaQ.optTopRun1!</code></a></li><li><a href="#SNaQ.optTopRuns!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, AbstractString, AbstractString, Integer, Float64}"><code>SNaQ.optTopRuns!</code></a></li><li><a href="#SNaQ.proposedTop!-Tuple{Integer, HybridNetwork, Bool, Integer, Integer, Vector{Int64}, Vector{Int64}, Bool}"><code>SNaQ.proposedTop!</code></a></li><li><a href="#SNaQ.readInputData-Tuple{AbstractString, AbstractString, Symbol, Integer, Bool, AbstractString, Bool, Bool}"><code>SNaQ.readInputData</code></a></li><li><a href="#SNaQ.sameTaxa-Tuple{Quartet, HybridNetwork}"><code>SNaQ.sameTaxa</code></a></li><li><a href="#SNaQ.sampleCFfromCI"><code>SNaQ.sampleCFfromCI</code></a></li><li><a href="#SNaQ.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>SNaQ.setGammaBLfromGammaz!</code></a></li><li><a href="#SNaQ.setLength!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Number}"><code>SNaQ.setLength!</code></a></li><li><a href="#SNaQ.setNonIdBL!-Tuple{HybridNetwork}"><code>SNaQ.setNonIdBL!</code></a></li><li><a href="#SNaQ.sorttaxa!-Tuple{DataCF}"><code>SNaQ.sorttaxa!</code></a></li><li><a href="#SNaQ.taxadiff-Tuple{Vector{Quartet}, HybridNetwork}"><code>SNaQ.taxadiff</code></a></li><li><a href="#SNaQ.traverseContainRoot!-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Bool}}"><code>SNaQ.traverseContainRoot!</code></a></li><li><a href="#SNaQ.undirectedOtherNetworks-Tuple{HybridNetwork}"><code>SNaQ.undirectedOtherNetworks</code></a></li><li><a href="#SNaQ.undoGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>SNaQ.undoGammaz!</code></a></li><li><a href="#SNaQ.updateBL!-Tuple{HybridNetwork, DataCF}"><code>SNaQ.updateBL!</code></a></li><li><a href="#SNaQ.updateContainRoot!"><code>SNaQ.updateContainRoot!</code></a></li><li><a href="#SNaQ.writenewick_level1-Tuple{HybridNetwork}"><code>SNaQ.writenewick_level1</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../public/">« Public</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Tuesday 6 May 2025 17:41">Tuesday 6 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
